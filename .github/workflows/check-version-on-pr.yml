name: Check VERSION on pull request

on:
  pull_request:
    types: [opened, edited, labeled, unlabeled, synchronize, reopened]

jobs:
  check-version:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: |
          git fetch --tags origin

      - name: Compute candidate version and comment
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          BASE_REF="${{ github.event.pull_request.base.ref }}"
          echo "Base ref: $BASE_REF"

          # Prefer querying the PR live (so re-runs pick up labels added after the original event)
          PR_NUM=$(jq -r '.pull_request.number' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          if [ -n "$PR_NUM" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            LABELS=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${{ github.repository }}/pulls/${PR_NUM}" | jq -r '.labels[]?.name' 2>/dev/null || true)
          else
            # Fallback to event payload labels
            LABELS=$(jq -r '.pull_request.labels[]?.name' "$GITHUB_EVENT_PATH" 2>/dev/null || true)
          fi
          LABELS_LOWER=$(echo "$LABELS" | tr '[:upper:]' '[:lower:]' || true)
          echo "PR labels:"
          echo "$LABELS_LOWER"

          # Enforce that PR labels are present
          if [ -z "$(echo "$LABELS_LOWER" | tr -d '[:space:]')" ]; then
            echo "ERROR: PR must include at least one label (major, minor, or patch)."
            echo "No labels found on PR; failing the job as labels are required."
            exit 1
          fi

          # Determine latest tag on base branch
          LATEST_TAG=""
          if git rev-parse --verify --quiet "refs/tags/$(git describe --tags --abbrev=0 origin/$BASE_REF 2>/dev/null)" >/dev/null 2>&1; then
            LATEST_TAG=$(git describe --tags --abbrev=0 origin/$BASE_REF)
          fi
          echo "Latest tag on base: $LATEST_TAG"

          # Determine bump
          BUMP="patch"
          if echo "$LABELS_LOWER" | grep -q "major"; then
            BUMP="major"
          elif echo "$LABELS_LOWER" | grep -q "minor"; then
            BUMP="minor"
          elif echo "$LABELS_LOWER" | grep -q "patch"; then
            BUMP="patch"
          fi
          echo "Selected bump: $BUMP"

          # Compute new version
          if [ -z "$LATEST_TAG" ]; then
            if [ "$BUMP" = "major" ]; then
              NEW_VERSION="v1.0.0"
            else
              NEW_VERSION="v0.1.0"
            fi
          else
            BASE=${LATEST_TAG#v}
            IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE}"
            MAJOR=${MAJOR:-0}
            MINOR=${MINOR:-0}
            PATCH=${PATCH:-0}
            if [ "$BUMP" = "major" ]; then
              MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0
            elif [ "$BUMP" = "minor" ]; then
              MINOR=$((MINOR+1)); PATCH=0
            else
              PATCH=$((PATCH+1))
            fi
            NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          fi

          echo "Computed candidate version for this PR: $NEW_VERSION"
          # Save the comment body into a temporary file and use the action below to post
          # Use printf so the \n sequences become real newlines in the file
          printf '%s\n\n%s\n' \
            "Computed release version if merged to $BASE_REF: **$NEW_VERSION**" \
            "Labels considered: $LABELS_LOWER" > /tmp/pr_version_comment.md

      - name: Post PR comment with computed version
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          COMMENT_BODY=$(cat /tmp/pr_version_comment.md)
          API_URL="https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"
          echo "Posting comment to $API_URL"
          curl -s -H "Authorization: token $GITHUB_TOKEN" -H "Content-Type: application/json" \
            -d "$(jq -nc --arg body "$COMMENT_BODY" '{body:$body}')" "$API_URL" >/dev/null

      - name: Auto-apply bump to PR branch (same-repo PRs)
        if: ${{ github.event.pull_request.head.repo.full_name == github.repository }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          echo "PR is from same repo; attempting to apply bump to PR branch"
          chmod +x .github/scripts/bump-version.sh || true

          # fetch the PR branch and checkout
          git fetch --no-tags origin +refs/heads/${{ github.event.pull_request.head.ref }}:refs/remotes/origin/${{ github.event.pull_request.head.ref }} || true
          git checkout -B "${{ github.event.pull_request.head.ref }}" "origin/${{ github.event.pull_request.head.ref }}"

          # get live labels for the PR
          PR_NUM=${{ github.event.pull_request.number }}
          PR_LABELS_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUM}" | jq -c '.labels // []' 2>/dev/null || echo '[]')
          export PR_LABELS="$PR_LABELS_JSON"

          # run bump in apply mode (will edit package.json)
          ./.github/scripts/bump-version.sh package.json auto --apply

          # regenerate package-lock.json so the lockfile matches the bumped version
          if command -v npm >/dev/null 2>&1; then
            echo "Regenerating package-lock.json (package-lock-only)..."
            npm install --package-lock-only
            echo "package-lock.json version: $(node -e "console.log(require('./package-lock.json').version)")" || true
          else
            echo "npm not found; skipping package-lock update"
          fi

          # commit & push if there are changes
          if git status --porcelain | grep -q '^'; then
            git add package.json package-lock.json || true
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore(release): bump package.json version to $(jq -r .version package.json) [skip ci]" || true

            if git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}" HEAD:${{ github.event.pull_request.head.ref }}; then
              echo "Pushed bump to PR branch"
              # comment on PR to let reviewers know we applied the bump
              BODY="Applied automatic version bump to this PR: **$(jq -r .version package.json)**"
              curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$BODY" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
            else
              echo "Failed to push bump to PR branch; this may be a protected branch or disallowed by policy"
              exit 1
            fi
          else
            echo "No changes to commit (PR already contains the bump)"
          fi
