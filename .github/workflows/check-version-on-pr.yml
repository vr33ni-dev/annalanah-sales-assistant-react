name: Check VERSION on pull request

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  issues: write

jobs:
  compute-and-comment:
    concurrency:
      group: check-version-pr-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (read-only)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install auto
        run: |
          set -euo pipefail
          npm ci --silent || true
          npm install --no-save auto@latest

      - name: Compute candidate version (simulate merge + auto shipit --dry-run)
        id: compute_version
        env:
          PR_NUM: ${{ github.event.pull_request.number }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          export PATH="./node_modules/.bin:$PATH"
          echo "PR number: ${PR_NUM}, base: ${BASE_REF}"

          # Ensure base branch is available
          git fetch --no-tags origin +refs/heads/${BASE_REF}:refs/remotes/origin/${BASE_REF} || true

          # Prefer GitHub's merge ref (test merge). If not present, do a local merge of PR head into base.
          if git fetch origin "pull/${PR_NUM}/merge" >/dev/null 2>&1; then
            git checkout -q FETCH_HEAD
          else
            git fetch origin "pull/${PR_NUM}/head:pr-${PR_NUM}" || true
            git checkout -q origin/${BASE_REF}
            git merge --no-ff --no-edit pr-${PR_NUM} || true
          fi

          # Ensure git committer identity so auto can create local commits during dry-run
          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true
          export GIT_COMMITTER_NAME="github-actions[bot]"
          export GIT_COMMITTER_EMAIL="41898282+github-actions[bot]@users.noreply.github.com"

          # Run auto shipit --dry-run only (no fallbacks)
          AUTO_OUT=$(npx auto shipit --dry-run 2>&1 || true)
          printf '%s\n' "---- auto shipit --dry-run output ----"
          printf '%s\n' "$AUTO_OUT"
          printf '%s\n' "---- end auto output ----"

          # Extract first semver (allow optional leading 'v')
          # Prefer the last semver in auto output (auto prints current/latest then the would-be release)
          NEW_VERSION=$(printf '%s' "$AUTO_OUT" | grep -E -o 'v?[0-9]+\.[0-9]+\.[0-9]+' | tail -n1 || true)
          if [ -z "$(printf '%s' "$NEW_VERSION" | tr -d '[:space:]')" ]; then
            echo "auto shipit did not produce a semver; aborting (no fallback)" >&2
            exit 1
          fi
          case "$NEW_VERSION" in
            v*) ;;
            *) NEW_VERSION="v${NEW_VERSION}" ;;
          esac

          echo "candidate_version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"

          # Determine current version on base: prefer latest tag, else package.json on base
          CURRENT_TAG=$(git describe --tags --abbrev=0 origin/${BASE_REF} 2>/dev/null || true)
          if [ -n "${CURRENT_TAG}" ]; then
            CURRENT_VERSION="${CURRENT_TAG}"
          else
            CURRENT_PKG=$(git show origin/${BASE_REF}:package.json 2>/dev/null || true)
            CURRENT_VERSION="v$(printf '%s' "$CURRENT_PKG" | jq -r .version 2>/dev/null || echo '0.0.0')"
          fi

          # Write comment body to temp file (hidden marker for updates)
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          printf '%s\n\n%s\n\nLast updated: %s\n' \
            "Current version on ${BASE_REF}: **${CURRENT_VERSION}**" \
            "Computed release version if merged to ${BASE_REF}: **${NEW_VERSION}** (computed by auto shipit --dry-run)" \
            "$TIMESTAMP" > /tmp/pr_version_comment.md
          # Hidden marker for finding/updating this comment
          printf '%s\n' "<!-- version-bot-comment -->" >> /tmp/pr_version_comment.md

      - name: Post or update PR comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO=${{ github.repository }}
          COMMENTS_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUMBER}/comments"
          RAW_COMMENT=$(cat /tmp/pr_version_comment.md)
          # Token selection: prefer secrets.GH_TOKEN, then secrets.RELEASE_PAT, then built-in GITHUB_TOKEN
          PICKED=""
          # Try explicit secret named GH_TOKEN first
          if [ -n "${{ secrets.GH_TOKEN }}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ secrets.GH_TOKEN }}" https://api.github.com/user || true)
            if [ "${HTTP_CODE}" = "200" ]; then
              PICKED="${{ secrets.GH_TOKEN }}"
              echo "Using secrets.GH_TOKEN"
            else
              echo "secrets.GH_TOKEN test returned HTTP ${HTTP_CODE}; skipping"
            fi
          fi

          # Next try RELEASE_PAT
          if [ -z "${PICKED}" ] && [ -n "${{ secrets.RELEASE_PAT }}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${{ secrets.RELEASE_PAT }}" https://api.github.com/user || true)
            if [ "${HTTP_CODE}" = "200" ]; then
              PICKED="${{ secrets.RELEASE_PAT }}"
              echo "Using secrets.RELEASE_PAT"
            else
              echo "secrets.RELEASE_PAT test returned HTTP ${HTTP_CODE}; skipping"
            fi
          fi

          # Finally try the built-in GITHUB_TOKEN (may be empty for fork PRs)
          if [ -z "${PICKED}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/user || true)
            if [ "${HTTP_CODE}" = "200" ]; then
              PICKED="${GITHUB_TOKEN}"
              echo "Using built-in GITHUB_TOKEN"
            else
              echo "built-in GITHUB_TOKEN test returned HTTP ${HTTP_CODE}; skipping"
            fi
          fi

          if [ -z "${PICKED}" ]; then
            echo "No valid token available for posting comments; skipping comment creation (normal for fork PRs)."
            echo "Would have posted the following comment body:" >&2
            printf '%s\n' "$RAW_COMMENT" >&2
            exit 0
          fi

          # Use the picked token for subsequent API calls
          AUTH_TOKEN="${PICKED}"

          # List comments and find an existing bot comment by hidden marker
          COMMENTS_JSON=$(curl -s -H "Authorization: token ${AUTH_TOKEN}" "${COMMENTS_URL}" || true)
          EXISTING_ID=$(printf '%s' "$COMMENTS_JSON" | jq -r '.[] | select((.body|contains("<!-- version-bot-comment -->")) and (.user.type=="Bot")) | .id' | head -n1 || true)

          if [ -n "$(printf '%s' "$EXISTING_ID" | tr -d '[:space:]')" ] && [ "$EXISTING_ID" != "null" ]; then
            echo "Found existing bot comment id=${EXISTING_ID}; evaluating whether update is needed"
            # Extract the existing comment body for comparison
            EXISTING_BODY=$(printf '%s' "$COMMENTS_JSON" | jq -r --arg id "$EXISTING_ID" '.[] | select((.id|tostring)==$id) | .body' || true)
            # Remove hidden marker and timestamp line, then normalize whitespace for comparison
            EXISTING_TEXT=$(printf '%s' "$EXISTING_BODY" | sed '/<!-- version-bot-comment -->/d' | sed '/Last updated:/d' | sed '/^[[:space:]]*$/d' | sed 's/[[:space:]]\+/ /g' | sed 's/^ //; s/ $//')
            NEW_TEXT=$(printf '%s' "$RAW_COMMENT" | sed '/<!-- version-bot-comment -->/d' | sed '/Last updated:/d' | sed '/^[[:space:]]*$/d' | sed 's/[[:space:]]\+/ /g' | sed 's/^ //; s/ $//')

            if [ "${EXISTING_TEXT}" = "${NEW_TEXT}" ]; then
              # Content is identical aside from timestamp. Update only if timestamp changed so
              # the comment shows a fresh "Last updated" line, otherwise skip to avoid churn.
              EXISTING_TS=$(printf '%s' "$EXISTING_BODY" | grep -E '^Last updated:' | sed 's/^Last updated:[[:space:]]*//' || true)
              NEW_TS=$(printf '%s' "$RAW_COMMENT" | grep -E '^Last updated:' | sed 's/^Last updated:[[:space:]]*//' || true)
              if [ "${EXISTING_TS}" != "${NEW_TS}" ]; then
                echo "Content identical but timestamp changed; updating existing bot comment id=${EXISTING_ID} to refresh timestamp"
                UPDATE_URL="https://api.github.com/repos/${REPO}/issues/comments/${EXISTING_ID}"
                PAYLOAD=$(jq -nc --arg body "$RAW_COMMENT" '{body:$body}')
                HTTP_STATUS=$(curl -s -o /tmp/comment_resp -w "%{http_code}" -X PATCH -H "Authorization: token ${AUTH_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "$UPDATE_URL" || true)
                echo "HTTP status: $HTTP_STATUS"
                cat /tmp/comment_resp || true
                if [ "${HTTP_STATUS}" -ge 400 ]; then
                  echo "Failed to update comment (status=$HTTP_STATUS)" >&2
                  exit 1
                fi
              else
                echo "Existing comment content is identical and timestamp unchanged; skipping update."
              fi
            else
              echo "Updating existing bot comment id=${EXISTING_ID}"
              UPDATE_URL="https://api.github.com/repos/${REPO}/issues/comments/${EXISTING_ID}"
              PAYLOAD=$(jq -nc --arg body "$RAW_COMMENT" '{body:$body}')
              HTTP_STATUS=$(curl -s -o /tmp/comment_resp -w "%{http_code}" -X PATCH -H "Authorization: token ${AUTH_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "$UPDATE_URL" || true)
              echo "HTTP status: $HTTP_STATUS"
              cat /tmp/comment_resp || true
              if [ "${HTTP_STATUS}" -ge 400 ]; then
                echo "Failed to update comment (status=$HTTP_STATUS)" >&2
                exit 1
              fi
            fi
          else
            echo "No existing bot comment found; creating new bot comment"
            PAYLOAD=$(jq -nc --arg body "$RAW_COMMENT" '{body:$body}')
            HTTP_STATUS=$(curl -s -o /tmp/comment_resp -w "%{http_code}" -H "Authorization: token ${AUTH_TOKEN}" -H "Content-Type: application/json" -d "$PAYLOAD" "$COMMENTS_URL" || true)
            echo "HTTP status: $HTTP_STATUS"
            cat /tmp/comment_resp || true
            if [ "${HTTP_STATUS}" -ge 400 ]; then
              echo "Failed to create comment (status=$HTTP_STATUS)" >&2
              exit 1
            fi
          fi
