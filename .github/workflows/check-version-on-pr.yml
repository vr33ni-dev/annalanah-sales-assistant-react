name: Check VERSION on pull request

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, labeled, unlabeled]

permissions:
  contents: read
  issues: write

jobs:
  compute-candidate:
    runs-on: ubuntu-latest
    outputs:
      candidate_version: ${{ steps.compute_and_comment.outputs.candidate_version }}
      token_source: ${{ steps.compute_and_comment.outputs.token_source }}
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Compute candidate version (auto) and post comment
        id: compute_and_comment
        env:
          REPO: ${{ github.repository }}
          PR_NUM: ${{ github.event.pull_request.number }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          # Prefer an org/repo secret explicitly named GH_TOKEN if available
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # If set to "true" the step will fail when no valid token is found.
          # Useful to enforce that PR checks must have a token available.
          TOKEN_FAIL_ON_NONE: "false"
          # Provide the PR head sha so we can simulate a merge into the base branch
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          export PATH="./node_modules/.bin:$PATH"

          # If a GH_TOKEN was provided directly via secrets.GH_TOKEN prefer it.
          # Otherwise fall back to RELEASE_PAT or the built-in GH_TOKEN.
          if [ -n "${GH_TOKEN:-}" ]; then
            echo "Using GH_TOKEN from secrets"
          else
            if [ -n "${RELEASE_PAT:-}" ]; then
              GITHUB_TOKEN="$RELEASE_PAT"
            else
              GITHUB_TOKEN="${GH_TOKEN:-}"
            fi
            export GITHUB_TOKEN
          fi

          # Diagnostic: report presence without printing the token value
          if [ -z "${GH_TOKEN:-}" ] && [ -z "${RELEASE_PAT:-}" ] && [ -z "${GITHUB_TOKEN:-}" ]; then
            echo "Warning: no token values are available in the environment. Auto will fail if it needs GH access."
          else
            echo "Token values present (specific values hidden). Will validate and pick one for API calls."
          fi

          # Token selection: try available tokens in order and pick the first that
          # returns HTTP 200 from /user. Order: secrets.GH_TOKEN, secrets.RELEASE_PAT, built-in GITHUB_TOKEN.
          PICKED=""

          if [ -n "${GH_TOKEN:-}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GH_TOKEN}" https://api.github.com/user || true)
            if [ "${HTTP_CODE}" = "200" ]; then
              PICKED="${GH_TOKEN}"
              echo "Using GH_TOKEN from secrets"
            else
              echo "secrets.GH_TOKEN test returned HTTP ${HTTP_CODE}; skipping"
            fi
          fi

          if [ -z "${PICKED}" ] && [ -n "${RELEASE_PAT:-}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${RELEASE_PAT}" https://api.github.com/user || true)
            if [ "${HTTP_CODE}" = "200" ]; then
              PICKED="${RELEASE_PAT}"
              echo "Using RELEASE_PAT from secrets"
            else
              echo "RELEASE_PAT test returned HTTP ${HTTP_CODE}; skipping"
            fi
          fi

          if [ -z "${PICKED}" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/user || true)
            if [ "${HTTP_CODE}" = "200" ]; then
              PICKED="${GITHUB_TOKEN}"
              echo "Using built-in GITHUB_TOKEN"
            else
              echo "built-in GITHUB_TOKEN test returned HTTP ${HTTP_CODE}; skipping"
            fi
          fi

          TOKEN_SOURCE="none"
          if [ -n "${PICKED}" ]; then
            GH_TOKEN="${PICKED}"
            export GH_TOKEN
            # determine which source we picked
            if [ "${PICKED}" = "${GH_TOKEN}" ] && [ -n "${GH_TOKEN:-}" ]; then
              TOKEN_SOURCE="GH_TOKEN"
            fi
            echo "GH_TOKEN set for subsequent API calls."
          else
            echo "No valid token found; GH_TOKEN will be empty and API calls will be skipped."
            unset GH_TOKEN || true
          fi

          # If we didn't already set TOKEN_SOURCE to GH_TOKEN, check the other candidates
          if [ "$TOKEN_SOURCE" = "none" ]; then
            if [ -n "${RELEASE_PAT:-}" ]; then
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${RELEASE_PAT}" https://api.github.com/user || true)
              if [ "$HTTP_CODE" = "200" ]; then
                TOKEN_SOURCE="RELEASE_PAT"
              fi
            fi
          fi
          if [ "$TOKEN_SOURCE" = "none" ] && [ -n "${GITHUB_TOKEN:-}" ]; then
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token ${GITHUB_TOKEN}" https://api.github.com/user || true)
            if [ "$HTTP_CODE" = "200" ]; then
              TOKEN_SOURCE="GITHUB_TOKEN"
            fi
          fi

          # Export the token_source as a step output for visibility
          echo "token_source=$TOKEN_SOURCE" >> "$GITHUB_OUTPUT"

          # Fail fast if requested
          if [ "${TOKEN_FAIL_ON_NONE:-false}" = "true" ] && [ "$TOKEN_SOURCE" = "none" ]; then
            echo "No valid token found and TOKEN_FAIL_ON_NONE=true; failing the job." >&2
            exit 1
          fi

          # Try to check out GitHub's merge ref for the PR (refs/pull/<num>/merge).
          # This avoids creating any local branches â€” we check out the merge
          # commit in a detached HEAD. If the merge ref is not available (rare),
          # fall back to creating a detached merged tree without writing branch refs.
          if [ -n "${PR_NUM:-}" ]; then
            MERGE_REF="refs/pull/${PR_NUM}/merge"
            if git ls-remote --exit-code origin "${MERGE_REF}" >/dev/null 2>&1; then
              echo "Checking out merge ref ${MERGE_REF} (detached)"
              git fetch origin "${MERGE_REF}" --no-tags
              git checkout --detach FETCH_HEAD || true
            else
              # Fallback: create a detached merged tree by checking out the base
              # and merging the PR head commit into it without creating a named branch.
              echo "Merge ref not available, creating a detached merged tree from origin/${BASE_REF} and PR head"
              git fetch --no-tags origin "${BASE_REF}" || true
              git checkout --detach origin/"${BASE_REF}" || true
              if [ -n "${PR_HEAD_SHA:-}" ]; then
                git fetch origin "${PR_HEAD_SHA}" || true
                git merge --no-edit --no-ff "${PR_HEAD_SHA}" || true
              fi
            fi
          else
            echo "PR_NUM not set; running auto on current checkout"
          fi

          RAW=$(npx --yes auto@latest version 2>&1 || true)
          echo "$RAW"

                - name: Post PR comment with computed version
                  env:
                    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                  run: |
                    set -euo pipefail
                    # If a prior step marked this run as a synchronize-sync from the actions bot
                    # or a [skip ci] commit, skip the comment update to avoid duplicate/refresh
                    # of the bot comment while still allowing the run to retry other actions.
                    if [ -f /tmp/skip_comment_update ]; then
                      echo "Skipping PR comment update for this run (marked by /tmp/skip_comment_update)."
                      exit 0
                    fi
                    # Build the comment body, but if an applied-line already exists in any
                    # bot comment, preserve that applied-line instead of writing (pending).
                    RAW_COMMENT=$(cat /tmp/pr_version_comment.md)
                    ISSUE_COMMENTS_URL="https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments"
                    echo "Looking for existing bot comment to update"
                    COMMENTS_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$ISSUE_COMMENTS_URL")

                    MARKER="Computed release version if merged to"
                    MARKER_HTML="<!-- version-bot-comment -->"
                    # First, try to extract an existing applied-line from any comment bodies
                    # so we preserve the original actor/timestamp and do not refresh it on
                    # compute-only runs.
                    APPLIED_LINE=$(echo "$COMMENTS_JSON" | jq -r '.[].body' | awk '/Applied automatic version bump to this PR:/{print; exit}' || true)
                    # If no applied-line is present in comments but the checked-out package.json
                    # already contains the computed version, construct an applied-line once
                    # so the computed comment reflects the applied state. Do not overwrite an
                    # existing applied-line (avoid updating timestamp repeatedly).
                    if [ -z "$(printf '%s' "$APPLIED_LINE")" ]; then
                      COMPUTED_V=$(printf '%s\n' "$RAW_COMMENT" | grep -o "v[0-9]\+\.[0-9]\+\.[0-9]\+" | head -n1 || true)
                      PKG_VERSION=$(jq -r .version package.json 2>/dev/null || true)
                      PKG_VERSION_V="v${PKG_VERSION:-}"
                      if [ -n "$(printf '%s' "$COMPUTED_V")" ] && [ "$COMPUTED_V" = "$PKG_VERSION_V" ]; then
                        APPLIED_LINE="Applied automatic version bump to this PR: **${COMPUTED_V}** (applied by ${GITHUB_ACTOR:-github-actions[bot]} on $(date -u +"%Y-%m-%dT%H:%M:%SZ"))"
                      fi
                    fi
                    if [ -n "$(printf '%s' "$APPLIED_LINE")" ]; then
                      # Build COMMENT_BODY by replacing the pending line with the applied line
                      # from the existing comment (keeps applied state and actor/timestamp).
                      BASE_LINE=$(printf '%s\n' "$RAW_COMMENT" | awk '/Computed release version if merged to/{print; exit}')
                      LABELS_LINE=$(printf '%s\n' "$RAW_COMMENT" | awk '/Labels considered:/{print; exit}')
                      COMMENT_BODY=$(printf '%s\n\n%s\n\n%s' "$BASE_LINE" "$LABELS_LINE" "$APPLIED_LINE")
                    else
                      COMMENT_BODY="$RAW_COMMENT"
                    fi

                    # Consolidate candidate comments so we only keep one bot-authored
                    # comment for this marker. Prefer bot-authored computed-version comments
                    # and remove any duplicate bot comments to avoid multiple pending/applied copies.
                    # Prefer comments that contain our hidden marker (guaranteed bot comment created by this workflow)
                    CANDIDATE_IDS=$(echo "$COMMENTS_JSON" | jq -r --arg marker_html "$MARKER_HTML" '.[] | select(.body | contains($marker_html)) | .id')
                    # Fallback to older heuristics for backwards compatibility
                    if [ -z "$(printf '%s' \"$CANDIDATE_IDS\")" ]; then
                      CANDIDATE_IDS=$(echo "$COMMENTS_JSON" | jq -r --arg marker "$MARKER" '.[] | select(.user.login=="github-actions[bot]" and (.body | contains($marker) or (.body | test("Applied automatic version bump to this PR:"))) ) | .id')
                    fi
                    EXISTING_ID=$(printf '%s\n' "$CANDIDATE_IDS" | head -n1 || true)
                    OTHER_IDS=$(printf '%s\n' "$CANDIDATE_IDS" | sed -n '2,$p' || true)
                    for dup in $OTHER_IDS; do
                      if [ -n "$dup" ]; then
                        echo "Deleting duplicate bot comment id=$dup"
                        curl -s -X DELETE -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${{ github.repository }}/issues/comments/${dup}" >/dev/null || true
                      fi
                    done

                    if [ -n "$EXISTING_ID" ] && [ "$EXISTING_ID" != "null" ]; then
                      echo "Found existing bot comment id=$EXISTING_ID; updating"
                      UPDATE_URL="https://api.github.com/repos/${{ github.repository }}/issues/comments/${EXISTING_ID}"
                      curl -s -X PATCH -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$COMMENT_BODY" '{body:$body}')" "$UPDATE_URL" >/dev/null || true
                    else
                      echo "No existing bot comment found; creating a new comment"
                      curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$COMMENT_BODY" '{body:$body}')" "$ISSUE_COMMENTS_URL" >/dev/null || true
                    fi

                - name: Auto-apply bump to PR branch (handled by auto now)
                  # Disabled: bump application should be handled by `auto` in CI. This step
                  # previously attempted to apply bumps directly into PR branches; keep the
                  # script here for reference but disable it so only `auto` produces the
                  # bump commit/tag during the release flow.
                  if: false
                  env:
                    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
                    GITHUB_REPOSITORY: ${{ github.repository }}
                    BASE_REF: ${{ github.event.pull_request.base.ref }}
                  run: |
                    set -euo pipefail
                    # ensure optional variables computed in other steps do not cause
                    # unbound-variable failures under -u (they may not be exported).
                    LATEST_TAG="${LATEST_TAG:-}"
                    BUMP="${BUMP:-patch}"
                    echo "PR is from same repo; attempting to apply bump to PR branch"
                    chmod +x .github/scripts/bump-version.sh || true

                    # fetch the PR branch and checkout
                    git fetch --no-tags origin +refs/heads/${{ github.event.pull_request.head.ref }}:refs/remotes/origin/${{ github.event.pull_request.head.ref }} || true
                    git checkout -B "${{ github.event.pull_request.head.ref }}" "origin/${{ github.event.pull_request.head.ref }}"

                    # get live labels for the PR
                    PR_NUM=${{ github.event.pull_request.number }}
                    PR_LABELS_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/pulls/${PR_NUM}" | jq -c '.labels // []' 2>/dev/null || echo '[]')
                    export PR_LABELS="$PR_LABELS_JSON"

                    # run bump in apply mode (will edit package.json)
                    ./.github/scripts/bump-version.sh package.json auto --apply

                    # regenerate package-lock.json so the lockfile matches the bumped version
                    if command -v npm >/dev/null 2>&1; then
                      echo "Regenerating package-lock.json (package-lock-only)..."
                      npm install --package-lock-only
                      echo "package-lock.json version: $(node -e "console.log(require('./package-lock.json').version)")" || true
                    else
                      echo "npm not found; skipping package-lock update"
                    fi
