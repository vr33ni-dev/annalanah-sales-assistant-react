name: Check VERSION on pull request

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  issues: write

jobs:
  compute-and-comment:
    concurrency:
      group: check-version-pr-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    runs-on: ubuntu-latest

    steps:
      - name: Checkout (read-only)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install auto
        run: |
          set -euo pipefail
          npm ci --silent || true
          npm install --no-save auto@latest

      - name: Compute candidate version (simulate merge + auto shipit --dry-run)
        id: compute_version
        env:
          PR_NUM: ${{ github.event.pull_request.number }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          export PATH="./node_modules/.bin:$PATH"
          echo "PR number: ${PR_NUM}, base: ${BASE_REF}"

          # Ensure base branch is available
          git fetch --no-tags origin +refs/heads/${BASE_REF}:refs/remotes/origin/${BASE_REF} || true

          # Prefer GitHub's merge ref (test merge). If not present, do a local merge of PR head into base.
          if git fetch origin "pull/${PR_NUM}/merge" >/dev/null 2>&1; then
            git checkout -q FETCH_HEAD
          else
            git fetch origin "pull/${PR_NUM}/head:pr-${PR_NUM}" || true
            git checkout -q origin/${BASE_REF}
            git merge --no-ff --no-edit pr-${PR_NUM} || true
          fi

          # Run auto shipit --dry-run only (no fallbacks)
          AUTO_OUT=$(npx auto shipit --dry-run 2>&1 || true)
          printf '%s\n' "---- auto shipit --dry-run output ----"
          printf '%s\n' "$AUTO_OUT"
          printf '%s\n' "---- end auto output ----"

          # Extract first semver (allow optional leading 'v')
          NEW_VERSION=$(printf '%s' "$AUTO_OUT" | grep -E -o 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)
          if [ -z "$(printf '%s' "$NEW_VERSION" | tr -d '[:space:]')" ]; then
            echo "auto shipit did not produce a semver; aborting (no fallback)" >&2
            exit 1
          fi
          case "$NEW_VERSION" in
            v*) ;;
            *) NEW_VERSION="v${NEW_VERSION}" ;;
          esac

          echo "candidate_version=${NEW_VERSION}" >> "$GITHUB_OUTPUT"

          # Determine current version on base: prefer latest tag, else package.json on base
          CURRENT_TAG=$(git describe --tags --abbrev=0 origin/${BASE_REF} 2>/dev/null || true)
          if [ -n "${CURRENT_TAG}" ]; then
            CURRENT_VERSION="${CURRENT_TAG}"
          else
            CURRENT_PKG=$(git show origin/${BASE_REF}:package.json 2>/dev/null || true)
            CURRENT_VERSION="v$(printf '%s' "$CURRENT_PKG" | jq -r .version 2>/dev/null || echo '0.0.0')"
          fi

          # Write comment body to temp file (hidden marker for updates)
          printf '%s\n\n%s\n' \
            "Current version on ${BASE_REF}: **${CURRENT_VERSION}**" \
            "Computed release version if merged to ${BASE_REF}: **${NEW_VERSION}** (computed by auto shipit --dry-run)" > /tmp/pr_version_comment.md
          printf '%s\n' "<!-- version-bot-comment -->" >> /tmp/pr_version_comment.md

      - name: Post or update PR comment
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          PR_NUMBER=${{ github.event.pull_request.number }}
          REPO=${{ github.repository }}
          COMMENTS_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUMBER}/comments"
          RAW_COMMENT=$(cat /tmp/pr_version_comment.md)

          # List comments and find an existing bot comment by hidden marker
          COMMENTS_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "${COMMENTS_URL}" || true)
          EXISTING_ID=$(printf '%s' "$COMMENTS_JSON" | jq -r '.[] | select(.user.login=="github-actions[bot]" and (.body|contains("<!-- version-bot-comment -->"))) | .id' | head -n1 || true)

          if [ -n "$(printf '%s' "$EXISTING_ID" | tr -d '[:space:]')" ] && [ "$EXISTING_ID" != "null" ]; then
            echo "Updating existing bot comment id=${EXISTING_ID}"
            UPDATE_URL="https://api.github.com/repos/${REPO}/issues/comments/${EXISTING_ID}"
            curl -s -X PATCH -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$RAW_COMMENT" '{body:$body}')" "$UPDATE_URL" >/dev/null || true
          else
            echo "Creating new bot comment"
            curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$RAW_COMMENT" '{body:$body}')" "$COMMENTS_URL" >/dev/null || true
          fi
