name: Compute candidate version (PR)

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, labeled, unlabeled]

permissions:
  contents: read
  issues: write

jobs:
  compute-candidate:
    runs-on: ubuntu-latest
    outputs:
      candidate_version: ${{ steps.compute_and_comment.outputs.candidate_version }}
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: "18"

      - name: Compute candidate version (auto) and post comment
        id: compute_and_comment
        env:
          REPO: ${{ github.repository }}
          PR_NUM: ${{ github.event.pull_request.number }}
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          # Prefer an org/repo secret explicitly named GH_TOKEN if available
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          # Provide the PR head sha so we can simulate a merge into the base branch
          PR_HEAD_SHA: ${{ github.event.pull_request.head.sha }}
        run: |
          set -euo pipefail

          export PATH="./node_modules/.bin:$PATH"

          if ! command -v auto >/dev/null 2>&1; then
            npm install --no-save auto@latest
          fi

          # If a GH_TOKEN was provided directly via secrets.GH_TOKEN prefer it.
          # Otherwise fall back to RELEASE_PAT or the built-in GITHUB_TOKEN.
          if [ -n "${GH_TOKEN:-}" ]; then
            echo "Using GH_TOKEN from secrets"
          else
            if [ -n "${RELEASE_PAT:-}" ]; then
              GH_TOKEN="$RELEASE_PAT"
            else
              GH_TOKEN="${GITHUB_TOKEN:-}"
            fi
            export GH_TOKEN
          fi

          # Diagnostic: report presence without printing the token value
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "Warning: GH_TOKEN is not set in the environment. Auto will fail if it needs GH access."
          else
            echo "GH_TOKEN is set (value hidden)"
          fi

          # Try to check out GitHub's merge ref for the PR (refs/pull/<num>/merge).
          # This avoids creating any local branches â€” we check out the merge
          # commit in a detached HEAD. If the merge ref is not available (rare),
          # fall back to creating a detached merged tree without writing branch refs.
          if [ -n "${PR_NUM:-}" ]; then
            MERGE_REF="refs/pull/${PR_NUM}/merge"
            if git ls-remote --exit-code origin "${MERGE_REF}" >/dev/null 2>&1; then
              echo "Checking out merge ref ${MERGE_REF} (detached)"
              git fetch origin "${MERGE_REF}" --no-tags
              git checkout --detach FETCH_HEAD || true
            else
              # Fallback: create a detached merged tree by checking out the base
              # and merging the PR head commit into it without creating a named branch.
              echo "Merge ref not available, creating a detached merged tree from origin/${BASE_REF} and PR head"
              git fetch --no-tags origin "${BASE_REF}" || true
              git checkout --detach origin/"${BASE_REF}" || true
              if [ -n "${PR_HEAD_SHA:-}" ]; then
                git fetch origin "${PR_HEAD_SHA}" || true
                git merge --no-edit --no-ff "${PR_HEAD_SHA}" || true
              fi
            fi
          else
            echo "PR_NUM not set; running auto on current checkout"
          fi

          RAW=$(npx auto version 2>&1 || true)
          echo "$RAW"

          CANDIDATE=$(echo "$RAW" | grep -Eo 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)

          if [ -z "$CANDIDATE" ]; then
            BUMP=$(echo "$RAW" | grep -Eo 'major|minor|patch' | head -n1 || true)
            if [ -z "$BUMP" ]; then
              echo "Could not parse auto output for semver or bump; failing."
              exit 1
            fi

            git fetch --no-tags origin "$BASE_REF" || true
            LATEST_TAG=$(git describe --tags --abbrev=0 origin/"$BASE_REF" 2>/dev/null || true)
            if [ -z "$LATEST_TAG" ]; then
              BASE_VERSION=$(jq -r .version package.json 2>/dev/null || echo "0.0.0")
            else
              BASE_VERSION=${LATEST_TAG#v}
            fi

            IFS='.' read -r MAJ MIN PAT <<< "${BASE_VERSION:-0.0.0}"
            MAJ=${MAJ:-0}; MIN=${MIN:-0}; PAT=${PAT:-0}
            if [ "$BUMP" = "major" ]; then
              MAJ=$((MAJ + 1)); MIN=0; PAT=0
            elif [ "$BUMP" = "minor" ]; then
              MIN=$((MIN + 1)); PAT=0
            else
              PAT=$((PAT + 1))
            fi
            CANDIDATE="v${MAJ}.${MIN}.${PAT}"
          else
            case "$CANDIDATE" in
              v*) ;;
              *) CANDIDATE="v${CANDIDATE}" ;;
            esac
          fi

          echo "Computed candidate: $CANDIDATE"
          echo "candidate_version=${CANDIDATE}" >> "$GITHUB_OUTPUT"

          COMMENTS_URL="https://api.github.com/repos/${REPO}/issues/${PR_NUM}/comments"
          BODY=$(printf 'Computed release version if merged to `%s`: **%s**\n\n(Computed by `auto version`)\n\n<!-- version-bot-comment -->' "$BASE_REF" "$CANDIDATE")

          # Use GH_TOKEN for API calls (prefer org secret)
          EXISTING_ID=$(curl -s -H "Authorization: token ${GH_TOKEN}" "${COMMENTS_URL}" | jq -r --arg marker '<!-- version-bot-comment -->' '.[] | select(.body | contains($marker)) | .id' | head -n1 || true)

          if [ -n "$EXISTING_ID" ] && [ "$EXISTING_ID" != "null" ]; then
            curl -s -X PATCH -H "Authorization: token ${GH_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$BODY" '{body:$body}')" "https://api.github.com/repos/${REPO}/issues/comments/${EXISTING_ID}" >/dev/null || true
          else
            curl -s -H "Authorization: token ${GH_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$BODY" '{body:$body}')" "${COMMENTS_URL}" >/dev/null || true
          fi
