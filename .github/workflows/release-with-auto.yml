name: Release (auto)

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    concurrency:
      group: release-with-auto-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          set -euo pipefail
          # Install project dependencies so npx auto uses the repo's version if present
          npm ci

      - name: Install pinned auto CLI
        run: |
          set -euo pipefail
          # Install a pinned auto version to avoid resolving scoped plugin packages
          # or relying on external registry auth. Pin to 10.x for compatibility with
          # existing .autorc (older format).
          npm install --no-save auto@10

      - name: Choose token for pushing tags/commits
        id: choose-token
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          # Prefer a user-provided PAT (recommended when branch protection prevents pushes by GH_TOKEN).
          if [ -n "${RELEASE_PAT:-}" ]; then
            echo "Using RELEASE_PAT for releasxe actions"
            echo "AUTO_TOKEN=${RELEASE_PAT}" >> "$GITHUB_ENV"
          else
            echo "No RELEASE_PAT configured; falling back to GH_TOKEN. If protected branches prevent pushes, create a RELEASE_PAT in repo secrets."
            echo "AUTO_TOKEN=${GH_TOKEN:-}" >> "$GITHUB_ENV"
          fi

      - name: Sanitize local git refs (CI only)
        # Remove local refs with malformed creatordate that can break tools parsing dates
        # This only affects the runner copy and is safe in CI (we do not modify remote)
        run: |
          set -euo pipefail
          echo "Running local-ref sanitization"
          bash ./.github/scripts/sanitize-local-refs.sh

      - name: Create release (compute version + changelog, call GitHub API)
        env:
          # Expose repo context and token; AUTO_TOKEN is written to $GITHUB_ENV in the previous step
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_SHA: ${{ github.sha }}
          OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail
          # Use auto only to compute the candidate version. Auto's 'release' command exercises the
          # GitHub Search API which can fail in some environments; computing the version with
          # 'auto version' and creating the release via the REST API avoids that.
          echo "STEP: computing candidate version with 'auto version'"
          LATEST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
          if [ -n "${LATEST_TAG:-}" ]; then
            RANGE="${LATEST_TAG}..origin/main"
          else
            RANGE="origin/main"
          fi
          # Ensure we have commits and tags from origin
          git fetch --tags origin main

          # Sanitize any refs fetched from origin that may have malformed dates
          # (This removes bad local copies fetched from origin so tools like `auto` don't crash.)
          bash ./.github/scripts/sanitize-local-refs.sh || true

          # Diagnostic: dump all refs and run remote-scan for CI debugging, then upload as artifact
          echo "Dumping refs and running remote scan for diagnostics"
          git for-each-ref --format='%(refname) %(objectname) %(objecttype) %(creatordate:raw) %(subject)' > refs-with-creatordate.raw || true

          # Run remote scan using a tokenized URL if AUTO_TOKEN is available; otherwise use origin remote
          if [ -n "${AUTO_TOKEN:-}" ]; then
            REMOTE_URL="https://x-access-token:${AUTO_TOKEN}@github.com/${OWNER}/${REPO_NAME}.git"
          else
            REMOTE_URL=$(git config --get remote.origin.url || true)
          fi
          bash ./.github/scripts/find-remote-suspicious-refs.sh "$REMOTE_URL" > remote-scan.txt 2>&1 || true

          # Upload artifacts (using the GitHub Actions upload action in later step)
          # Write marker so the workflow can pick these up
          echo "ARTIFACTS_TO_UPLOAD=refs-with-creatordate.raw remote-scan.txt" >> "$GITHUB_ENV" || true

          # Compute candidate via auto (auto version prints the next version).
          # Make the chosen token available as GH_TOKEN for auto and guard the
          # invocation so failures do not abort the whole job.
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"

          # NOTE: runner-side debugging and sanitization were removed to avoid
          # deleting local refs in CI runs. We keep the token export and the
          # safe fallback logic below so releases continue even if `auto`
          # encounters errors.

          # Run auto and capture full output for diagnostics (don't print secrets)
          RAW_VERSION=$(npx auto version 2>&1 || true)
          echo "auto version output (trimmed):" >&2
          printf '%s\n' "${RAW_VERSION:-}" | sed -n '1,60p' >&2 || true
          # Also dump the full raw output (helpful when auto errors) to logs
          echo "auto version output (full):" >&2
          printf '%s\n' "${RAW_VERSION:-}" >&2 || true

          # Try to extract a semver-like token (allow optional leading 'v')
          CANDIDATE=$(printf "%s" "$RAW_VERSION" | grep -Eo 'v?[0-9]+\.[0-9]+\.[0-9]+' | tail -n1 || true)

          if [ -n "$CANDIDATE" ]; then
            # Normalize tag name to start with 'v'
            case "$CANDIDATE" in
              v*) TAG_NAME="$CANDIDATE" ;;
              *) TAG_NAME="v$CANDIDATE" ;;
            esac
            echo "Computed candidate tag from auto: $TAG_NAME"
          else
            # auto failed or returned unexpected output (e.g. gitlog crash).
            # Fall back to a conservative git-based patch bump so releases
            # continue instead of failing the workflow.
            echo "Warning: 'auto version' did not return a semver; falling back to git-based bump" >&2
            printf '%s\n' "${RAW_VERSION:-}" >&2 || true
            if [ -n "${LATEST_TAG:-}" ]; then
              BASE=${LATEST_TAG#v}
              IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE}"
              MAJOR=${MAJOR:-0}
              MINOR=${MINOR:-0}
              PATCH=${PATCH:-0}
              PATCH=$((PATCH+1))
              TAG_NAME="v${MAJOR}.${MINOR}.${PATCH}"
            else
              # No prior tag found, start at v0.1.0 by default
              TAG_NAME="v0.1.0"
            fi
            echo "Fallback candidate tag: $TAG_NAME"
          fi

          echo "Computed candidate tag: $TAG_NAME"

          # Build a changelog from git history between the last tag and origin/main
          echo "Building changelog for range: $RANGE"
          CHANGELOG=$(git --no-pager log "$RANGE" --pretty=format:"- %s (%an, %h)%n%n%b%n")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changelog entries generated by git log for range $RANGE"
          fi

          # Create GitHub release using REST API (use AUTO_TOKEN which was written earlier)
          echo "Ensuring tag ${TAG_NAME} exists and pushing it if we can"
          # Configure git user for tag creation
          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true

          # Create annotated tag locally if it doesn't exist
          if ! git rev-parse --verify "refs/tags/${TAG_NAME}" >/dev/null 2>&1; then
            echo "Creating annotated tag ${TAG_NAME}"
            git tag -a "${TAG_NAME}" -m "Release ${TAG_NAME}" || true
          else
            echo "Tag ${TAG_NAME} already exists locally"
          fi

          # Push tag if AUTO_TOKEN is available (prefer RELEASE_PAT). We push via HTTPS
          # using the token to authenticate so protected-branch rules are respected.
          if [ -n "${AUTO_TOKEN:-}" ]; then
            echo "Pushing tag ${TAG_NAME} to origin using provided token"
            AUTH_REMOTE="https://x-access-token:${AUTO_TOKEN}@github.com/${OWNER}/${REPO_NAME}.git"
            # Ensure the remote exists under that URL temporarily
            git remote add authtemp "$AUTH_REMOTE" 2>/dev/null || true
            git push authtemp "${TAG_NAME}" --follow-tags --force || git push authtemp "refs/tags/${TAG_NAME}:refs/tags/${TAG_NAME}" || true
            git remote remove authtemp 2>/dev/null || true
          else
            echo "No AUTO_TOKEN available; skipping git push of tag (Releases API may still create the release referencing the tag name)."
          fi

          echo "Creating GitHub release $TAG_NAME"
          # Build JSON payload
          # Export variables so node can see them via process.env
          export TAG_NAME="$TAG_NAME"
          export CHANGELOG="$CHANGELOG"
          PAYLOAD=$(node -e 'const d={tag_name:process.env.TAG_NAME,name:process.env.TAG_NAME,body:process.env.CHANGELOG||"",draft:false,prerelease:false,target_commitish:process.env.GITHUB_SHA||"main"};console.log(JSON.stringify(d));')

          # Call GitHub Releases API
          API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}/releases"
          HTTP_STATUS=$(printf "%s" "$PAYLOAD" | curl -s -o /dev/stderr -w "%{http_code}" -X POST \
            -H "Authorization: token ${AUTO_TOKEN:-}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            --data @- "$API_URL" || true)

          if [ "$HTTP_STATUS" != "201" ] && [ "$HTTP_STATUS" != "200" ]; then
            echo "GitHub API returned HTTP $HTTP_STATUS when creating release" >&2
            exit 1
          fi
          echo "Release $TAG_NAME created successfully."
