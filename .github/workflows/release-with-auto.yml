name: Release (auto)

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    concurrency:
      group: release-with-auto-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          set -euo pipefail
          # Use npm install here (not npm ci) because package.json was edited in-tree
          # and the lockfile may not yet match on CI. This installs dependencies
          # including the pinned 'auto' devDependency.
          npm install --no-audit --no-fund

      # auto is installed by `npm ci` from devDependencies (pinned in package.json)

      - name: Choose token for pushing tags/commits
        id: choose-token
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          # Prefer a user-provided PAT (recommended when branch protection prevents pushes by GH_TOKEN).
          if [ -n "${RELEASE_PAT:-}" ]; then
            echo "Using RELEASE_PAT for releasxe actions"
            echo "AUTO_TOKEN=${RELEASE_PAT}" >> "$GITHUB_ENV"
          else
            echo "No RELEASE_PAT configured; falling back to GH_TOKEN. If protected branches prevent pushes, create a RELEASE_PAT in repo secrets."
            echo "AUTO_TOKEN=${GH_TOKEN:-}" >> "$GITHUB_ENV"
          fi

      - name: Expose GH_TOKEN for Auto
        run: |
          set -euo pipefail
          # Make GH_TOKEN available for the auto CLI which expects GH_TOKEN in env
          if [ -n "${AUTO_TOKEN:-}" ]; then
            echo "GH_TOKEN=${AUTO_TOKEN}" >> "$GITHUB_ENV"
          fi

      - name: Create release (compute version + changelog, call GitHub API)
        env:
          # Expose repo context and token; AUTO_TOKEN is written to $GITHUB_ENV in the previous step
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_SHA: ${{ github.sha }}
          OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail
          # Use auto only to compute the candidate version. Auto's 'release' command exercises the
          # GitHub Search API which can fail in some environments; computing the version with
          # 'auto version' and creating the release via the REST API avoids that.
          echo "STEP: computing candidate version with 'auto version'"
          LATEST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
          if [ -n "${LATEST_TAG:-}" ]; then
            RANGE="${LATEST_TAG}..origin/main"
          else
            RANGE="origin/main"
          fi
          # Ensure we have commits and tags from origin
          git fetch --tags origin main

          # Compute candidate via auto (auto version prints the next version)
          RAW_VERSION=$(npx auto version 2>&1 || true)
          # Extract a semver-like token (allow optional leading 'v')
          CANDIDATE=$(printf "%s" "$RAW_VERSION" | grep -Eo 'v?[0-9]+\.[0-9]+\.[0-9]+' | tail -n1 || true)
          if [ -z "$CANDIDATE" ]; then
            echo "Could not parse a semver from 'auto version' output:" >&2
            printf "%s\n" "$RAW_VERSION" >&2
            exit 1
          fi
          # Normalize tag name to start with 'v'
          case "$CANDIDATE" in
            v*) TAG_NAME="$CANDIDATE" ;;
            *) TAG_NAME="v$CANDIDATE" ;;
          esac

          echo "Computed candidate tag: $TAG_NAME"

          # Build a changelog from git history between the last tag and origin/main
          echo "Building changelog for range: $RANGE"
          CHANGELOG=$(git --no-pager log "$RANGE" --pretty=format:"- %s (%an, %h)%n%n%b%n")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changelog entries generated by git log for range $RANGE"
          fi

          # Create GitHub release using REST API (use AUTO_TOKEN which was written earlier)
          echo "Creating GitHub release $TAG_NAME"
          # Build JSON payload safely with python (available on runner)
          PAYLOAD=$(node -e 'const d={tag_name:process.env.TAG_NAME,name:process.env.TAG_NAME,body:process.env.CHANGELOG||"",draft:false,prerelease:false,target_commitish:process.env.GITHUB_SHA||"main"};console.log(JSON.stringify(d));')

          # Call GitHub Releases API
          API_URL="https://api.github.com/repos/${OWNER}/${REPO_NAME}/releases"
          HTTP_STATUS=$(printf "%s" "$PAYLOAD" | curl -s -o /dev/stderr -w "%{http_code}" -X POST \
            -H "Authorization: token ${AUTO_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Content-Type: application/json" \
            --data @- "$API_URL" || true)

          if [ "$HTTP_STATUS" != "201" ] && [ "$HTTP_STATUS" != "200" ]; then
            echo "GitHub API returned HTTP $HTTP_STATUS when creating release" >&2
            exit 1
          fi
          echo "Release $TAG_NAME created successfully."
