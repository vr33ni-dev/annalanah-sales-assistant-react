name: Release (auto)

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    concurrency:
      group: release-with-auto-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install dependencies
        run: |
          set -euo pipefail
          # Lightweight guard: if this run was triggered by the actions bot (a previous
          # automatic push from this workflow), exit early to avoid loops.
          if [ "${GITHUB_EVENT_NAME:-}" = "push" ] && [ "${GITHUB_ACTOR:-}" = "github-actions[bot]" ]; then
            echo "Run triggered by github-actions[bot]; exiting to avoid recursive release runs."
            exit 0
          fi
          # Install project dependencies so npx auto uses the repo's version if present
          npm ci

      - name: Install pinned auto CLI
        run: |
          set -euo pipefail
          # Install a pinned auto version to avoid resolving scoped plugin packages
          # or relying on external registry auth. Pin to 10.x for compatibility with
          # existing .autorc (older format).
          npm install --no-save auto@10

      - name: Choose token for pushing tags/commits
        id: choose-token
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          # Prefer a user-provided PAT (recommended when branch protection prevents pushes by GH_TOKEN).
          if [ -n "${RELEASE_PAT:-}" ]; then
            echo "Using RELEASE_PAT for releasxe actions"
            echo "AUTO_TOKEN=${RELEASE_PAT}" >> "$GITHUB_ENV"
          else
            echo "No RELEASE_PAT configured; falling back to GH_TOKEN. If protected branches prevent pushes, create a RELEASE_PAT in repo secrets."
            echo "AUTO_TOKEN=${GH_TOKEN:-}" >> "$GITHUB_ENV"
          fi

      - name: Sanitize local git refs (CI only)
        # Remove local refs with malformed creatordate that can break tools parsing dates
        # This only affects the runner copy and is safe in CI (we do not modify remote)
        run: |
          set -euo pipefail
          echo "Running local-ref sanitization"
          bash ./.github/scripts/sanitize-local-refs.sh

      - name: Create release (compute version + changelog, call GitHub API)
        env:
          # Expose repo context and token; AUTO_TOKEN is written to $GITHUB_ENV in the previous step
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_SHA: ${{ github.sha }}
          OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail
          # Use auto only to compute the candidate version. Auto's 'release' command exercises the
          # GitHub Search API which can fail in some environments; computing the version with
          # 'auto version' and creating the release via the REST API avoids that.
          echo "STEP: computing candidate version with 'auto version'"
          LATEST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
          if [ -n "${LATEST_TAG:-}" ]; then
            RANGE="${LATEST_TAG}..origin/main"
          else
            RANGE="origin/main"
          fi
          # Ensure we have commits and tags from origin
          git fetch --tags origin main

          # Sanitize any refs fetched from origin that may have malformed dates
          # (This removes bad local copies fetched from origin so tools like `auto` don't crash.)
          bash ./.github/scripts/sanitize-local-refs.sh || true

          # Diagnostic: dump all refs and run remote-scan for CI debugging, then upload as artifact
          echo "Dumping refs and running remote scan for diagnostics"
          git for-each-ref --format='%(refname) %(objectname) %(objecttype) %(creatordate:raw) %(subject)' > refs-with-creatordate.raw || true

          # Run remote scan using a tokenized URL if AUTO_TOKEN is available; otherwise use origin remote
          if [ -n "${AUTO_TOKEN:-}" ]; then
            REMOTE_URL="https://x-access-token:${AUTO_TOKEN}@github.com/${OWNER}/${REPO_NAME}.git"
          else
            REMOTE_URL=$(git config --get remote.origin.url || true)
          fi
          bash ./.github/scripts/find-remote-suspicious-refs.sh "$REMOTE_URL" > remote-scan.txt 2>&1 || true

          # Upload artifacts (using the GitHub Actions upload action in later step)
          # Write marker so the workflow can pick these up
          echo "ARTIFACTS_TO_UPLOAD=refs-with-creatordate.raw remote-scan.txt" >> "$GITHUB_ENV" || true

          # Compute candidate via auto (auto version prints the next version).
          # Make the chosen token available as GH_TOKEN for auto and guard the
          # invocation so failures do not abort the whole job.
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"

          # NOTE: runner-side debugging and sanitization were removed to avoid
          # deleting local refs in CI runs. We keep the token export and the
          # safe fallback logic below so releases continue even if `auto`
          # encounters errors.

          # Run auto and capture full output for diagnostics (don't print secrets)
            # Prefer using `auto shipit --dry-run` to get the full semver (vX.Y.Z)
            AUTO_SHIPIT_OUTPUT=$(npx auto shipit --dry-run 2>&1 || true)
            if [ -n "$(printf '%s' "$AUTO_SHIPIT_OUTPUT" | tr -d '[:space:]')" ]; then
              echo "---- auto shipit dry-run output ----"
              printf '%s\n' "$AUTO_SHIPIT_OUTPUT"
              echo "---- end auto shipit output ----"
            else
              echo "auto shipit produced no output or failed (non-fatal)"
            fi
            # Try to extract a semver from shipit output first (v1.2.3 or 1.2.3)
            CANDIDATE=$(printf '%s' "$AUTO_SHIPIT_OUTPUT" | grep -E -o 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)
            # If shipit did not yield a semver, fall back to `auto version` which emits the bump token
            if [ -z "$(printf '%s' "$CANDIDATE" | tr -d '[:space:]')" ]; then
              RAW_VERSION=$(npx auto version 2>&1 || true)
              echo "auto version output (trimmed):" >&2
              printf '%s\n' "${RAW_VERSION:-}" | sed -n '1,60p' >&2 || true
              echo "auto version output (full):" >&2
              printf '%s\n' "${RAW_VERSION:-}" >&2 || true
              CANDIDATE=$(printf "%s" "$RAW_VERSION" | grep -Eo 'v?[0-9]+\.[0-9]+\.[0-9]+' | tail -n1 || true)
            fi

          if [ -n "$CANDIDATE" ]; then
            # Normalize tag name to start with 'v'
            case "$CANDIDATE" in
              v*) TAG_NAME="$CANDIDATE" ;;
              *) TAG_NAME="v$CANDIDATE" ;;
            esac
            echo "Computed cand
            idate tag from auto: $TAG_NAME"
          else
            # auto failed or returned unexpected output (e.g. gitlog crash).
            # Fall back to a conservative git-based patch bump so releases
            # continue instead of failing the workflow.
            echo "Warning: 'auto version' did not return a semver; falling back to git-based bump" >&2
            printf '%s\n' "${RAW_VERSION:-}" >&2 || true
            if [ -n "${LATEST_TAG:-}" ]; then
              BASE=${LATEST_TAG#v}
              IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE}"
              MAJOR=${MAJOR:-0}
              MINOR=${MINOR:-0}
              PATCH=${PATCH:-0}
              PATCH=$((PATCH+1))
              TAG_NAME="v${MAJOR}.${MINOR}.${PATCH}"
            else
              # No prior tag found, start at v0.1.0 by default
              TAG_NAME="v0.1.0"
            fi
            echo "Fallback candidate tag: $TAG_NAME"
          fi

          echo "Computed candidate tag: $TAG_NAME"

          # --- New behavior: apply the version bump to package.json and push it ---
          # Ensure git identity is configured for commits
          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true

          echo "Applying computed version $TAG_NAME to package.json"
          # Strip leading 'v' for package.json version field
          NEW_PKG_VERSION="${TAG_NAME#v}"
          echo "Setting package.json version to $NEW_PKG_VERSION"
          node -e 'const fs=require("fs");const p=JSON.parse(fs.readFileSync("package.json","utf8"));p.version=process.argv[1];fs.writeFileSync("package.json",JSON.stringify(p,null,2)+"\n");' "$NEW_PKG_VERSION"

          # Regenerate lockfile to match updated package.json
          if [ -f package.json ]; then
            echo "Updating package-lock.json to reflect bumped package.json"
            npm install --package-lock-only || true
          fi

          # If package.json or package-lock.json changed, commit and push using AUTO_TOKEN
          if ! git diff --quiet -- package.json package-lock.json 2>/dev/null; then
            git add package.json package-lock.json || true
            git commit -m "chore(release): bump version to ${TAG_NAME}" || true
            if [ -n "${AUTO_TOKEN:-}" ]; then
              AUTH_REMOTE="https://x-access-token:${AUTO_TOKEN}@github.com/${OWNER}/${REPO_NAME}.git"
              git remote add authtemp "$AUTH_REMOTE" 2>/dev/null || true
              echo "Pushing version bump commit to origin/main via token-backed remote"
              git push authtemp HEAD:main || git push authtemp HEAD:${GITHUB_REF_NAME:-main} || true
              git remote remove authtemp 2>/dev/null || true
            else
              echo "No AUTO_TOKEN available; attempting to push via origin (may be blocked by branch protection)"
              git push origin HEAD:main || true
            fi
          else
            echo "No package.json or package-lock changes detected after auto version"
          fi

          # Build a changelog from git history between the last tag and origin/main
          echo "Building changelog for range: $RANGE"
          CHANGELOG=$(git --no-pager log "$RANGE" --pretty=format:"- %s (%an, %h)%n%n%b%n")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changelog entries generated by git log for range $RANGE"
          fi

          # Create the release using `auto shipit` now that package.json has been bumped
          echo "Running 'auto shipit' to publish the release for ${TAG_NAME}"
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"
          # Run auto shipit (non-dry) to create the tag/release on GitHub. It will operate
          # against the repo and create the release referencing the current HEAD (the bumped commit).
          npx auto shipit || {
            echo "auto shipit failed; aborting release step" >&2
            exit 1
          }
