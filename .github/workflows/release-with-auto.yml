name: Release (auto)

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    concurrency:
      group: release-with-auto-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node, install deps, and pinned auto
        run: |
          set -euo pipefail
          # Lightweight guard: if this run was triggered by the actions bot (a previous
          # automatic push from this workflow), exit early to avoid loops.
          if [ "${GITHUB_EVENT_NAME:-}" = "push" ] && [ "${GITHUB_ACTOR:-}" = "github-actions[bot]" ]; then
            echo "Run triggered by github-actions[bot]; exiting to avoid recursive release runs."
            exit 0
          fi
          # Verify Node/npm then install project dependencies first (npm ci).
          node -v || true
          npm --version || true
          npm ci
          # Install a pinned auto CLI after npm ci so it is not removed by the installer.
          npm install --no-save auto@latest

      - name: Choose token for pushing tags/commits
        id: choose-token
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          # Prefer a user-provided PAT (recommended when branch protection prevents pushes by GH_TOKEN).
          if [ -n "${RELEASE_PAT:-}" ]; then
            echo "Using RELEASE_PAT for release actions"
            echo "AUTO_TOKEN=${RELEASE_PAT}" >> "$GITHUB_ENV"
          else
            echo "No RELEASE_PAT configured; falling back to GH_TOKEN. If protected branches prevent pushes, create a RELEASE_PAT in repo secrets."
            echo "AUTO_TOKEN=${GH_TOKEN:-}" >> "$GITHUB_ENV"
          fi

      - name: Create release (compute version + changelog, call GitHub API)
        env:
          # Expose repo context and token; AUTO_TOKEN is written to $GITHUB_ENV in the previous step
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_SHA: ${{ github.sha }}
          OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail

          # Diagnostic: dump all refs and run remote-scan for CI debugging, then upload as artifact
          echo "Dumping refs for diagnostics (write to /tmp to keep workspace clean)"
          git for-each-ref --format='%(refname) %(objectname) %(objecttype) %(creatordate:raw) %(subject)' > /tmp/refs-with-creatordate.raw || true


          # Compute candidate via auto
          # Make the chosen token available as GH_TOKEN for auto and guard the
          # invocation so failures do not abort the whole job.
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"

          # Ensure git identity is configured before invoking `auto` which may
          # create temporary commits during dry-run. Without this auto can fail
          # with "Could not find a git name and email to commit with".
          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true

          # Initialize variables to avoid 'unbound variable' when set -u is used
          CANDIDATE=""
          RAW_VERSION=""

          # Run auto and capture full output for diagnostics (don't print secrets)
            # Prefer using `auto shipit --dry-run` to get the full semver (vX.Y.Z)
            AUTO_SHIPIT_OUTPUT=$(npx auto shipit --dry-run 2>&1 || true)
            if [ -n "$(printf '%s' "$AUTO_SHIPIT_OUTPUT" | tr -d '[:space:]')" ]; then
              echo "---- auto shipit dry-run output ----"
              printf '%s\n' "$AUTO_SHIPIT_OUTPUT"
              echo "---- end auto shipit output ----"
            else
              echo "auto shipit produced no output or failed (non-fatal)"
            fi

            # Try to extract a semver (v1.2.3 or 1.2.3) from the shipit output
            # Some versions of auto print messages like:
            #   "Would have created a release on GitHub for version: 0.1.24"
            # or
            #   "Would have published: 0.1.19"
            # so grep for the first semver-like token and prefer that as CANDIDATE.
            CANDIDATE=$(printf '%s' "$AUTO_SHIPIT_OUTPUT" | grep -E -o 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)

            # Ensure we have commits and tags from origin so CHANGELOG/RANGE calculations work
            git fetch --tags origin main || true
            LATEST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
            if [ -n "${LATEST_TAG:-}" ]; then
              RANGE="${LATEST_TAG}..origin/main"
            else
              RANGE="origin/main"
            fi

          if [ -n "$CANDIDATE" ]; then
            # Normalize tag name to start with 'v'
            case "$CANDIDATE" in
              v*) TAG_NAME="$CANDIDATE" ;;
              *) TAG_NAME="v$CANDIDATE" ;;
            esac
              echo "Computed candidate tag from auto: $TAG_NAME"
          else
            # auto failed or returned unexpected output (e.g. gitlog crash).
            # Fall back to a conservative git-based patch bump so releases
            # continue instead of failing the workflow.
            echo "Warning: 'auto shipit --dry-run' did not return a semver; falling back to git-based bump" >&2
            printf '%s\n' "${RAW_VERSION:-}" >&2 || true
            if [ -n "${LATEST_TAG:-}" ]; then
              BASE=${LATEST_TAG#v}
              IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE}"
              MAJOR=${MAJOR:-0}
              MINOR=${MINOR:-0}
              PATCH=${PATCH:-0}
              PATCH=$((PATCH+1))
              TAG_NAME="v${MAJOR}.${MINOR}.${PATCH}"
            else
              # No prior tag found, start at v0.1.0 by default
              TAG_NAME="v0.1.0"
            fi
            echo "Fallback candidate tag: $TAG_NAME"
          fi

          echo "Computed candidate tag: $TAG_NAME"

          # --- New behavior: apply the version bump to package.json and push it ---
          # Ensure git identity is configured for commits
          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true

          echo "Applying computed version $TAG_NAME to package.json"
          # Strip leading 'v' for package.json version field
          NEW_PKG_VERSION="${TAG_NAME#v}"
          echo "Setting package.json version to $NEW_PKG_VERSION"
          node -e 'const fs=require("fs");const p=JSON.parse(fs.readFileSync("package.json","utf8"));p.version=process.argv[1];fs.writeFileSync("package.json",JSON.stringify(p,null,2)+"\n");' "$NEW_PKG_VERSION"

          # Regenerate lockfile to match updated package.json
          if [ -f package.json ]; then
            echo "Updating package-lock.json to reflect bumped package.json"
            npm install --package-lock-only || true
          fi

          # If package.json or package-lock.json changed, commit and push.
          # Many repositories protect `main` and require PRs; instead of
          # pushing directly to main (which can be rejected), push the bump to a
          # release branch and open a PR so human review/required checks can run.
          SKIP_SHIPIT=0
          if ! git diff --quiet -- package.json package-lock.json 2>/dev/null; then
            git add package.json package-lock.json || true
            git commit -m "chore(release): bump version to ${TAG_NAME}" || true
            if [ -n "${AUTO_TOKEN:-}" ]; then
              AUTH_REMOTE="https://x-access-token:${AUTO_TOKEN}@github.com/${OWNER}/${REPO_NAME}.git"
              git remote add authtemp "$AUTH_REMOTE" 2>/dev/null || true
              echo "Pushing version bump commit to origin/main via token-backed remote"
              if ! git push authtemp HEAD:main; then
                echo "ERROR: Push to main failed. Branch protection likely prevents direct pushes. Ensure the provided RELEASE_PAT has permission to push to main or adjust branch protection settings." >&2
                git remote remove authtemp 2>/dev/null || true
                exit 1
              fi
              git remote remove authtemp 2>/dev/null || true
            else
              echo "No AUTO_TOKEN available; attempting to push via origin (may be blocked by branch protection)"
              if ! git push origin HEAD:main; then
                echo "ERROR: Push to main failed. Branch protection likely prevents direct pushes. Exiting." >&2
                exit 1
              fi
            fi
          else
            echo "No package.json or package-lock changes detected after auto shipit --dry-run"
          fi

          # Build a changelog from git history between the last tag and origin/main
          echo "Building changelog for range: $RANGE"
          CHANGELOG=$(git --no-pager log "$RANGE" --pretty=format:"- %s (%an, %h)%n%n%b%n")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changelog entries generated by git log for range $RANGE"
          fi

          # Create the release using `auto shipit` now that package.json has been bumped
          echo "Running 'auto shipit' to publish the release for ${TAG_NAME}"
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"
          # Run auto shipit (non-dry) to create the tag/release on GitHub. It will operate
          # against the repo and create the release referencing the current HEAD (the bumped commit).
          npx auto shipit || {
            echo "auto shipit failed; aborting release step" >&2
            exit 1
          }
