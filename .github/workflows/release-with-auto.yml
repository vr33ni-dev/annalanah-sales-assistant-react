name: Release (auto)

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  push:
    branches: [main]
  workflow_dispatch:

jobs:
  release:
    runs-on: ubuntu-latest
    concurrency:
      group: release-with-auto-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node, install deps, and pinned auto
        run: |
          set -euo pipefail
          # Lightweight guard: if this run was triggered by the actions bot (a previous
          # automatic push from this workflow), exit early to avoid loops.
          if [ "${GITHUB_EVENT_NAME:-}" = "push" ] && [ "${GITHUB_ACTOR:-}" = "github-actions[bot]" ]; then
            echo "Run triggered by github-actions[bot]; exiting to avoid recursive release runs."
            exit 0
          fi
          # Verify Node/npm then install project dependencies first (npm ci).
          node -v || true
          npm --version || true
          npm ci
          # Install a pinned auto CLI after npm ci so it is not removed by the installer.
          npm install --no-save auto@latest

      - name: Choose token for pushing tags/commits
        id: choose-token
        env:
          RELEASE_PAT: ${{ secrets.RELEASE_PAT }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          set -euo pipefail
          # Prefer a user-provided PAT (recommended when branch protection prevents pushes by GH_TOKEN).
          if [ -n "${RELEASE_PAT:-}" ]; then
            echo "Using RELEASE_PAT for release actions"
            echo "AUTO_TOKEN=${RELEASE_PAT}" >> "$GITHUB_ENV"
          else
            echo "No RELEASE_PAT configured; falling back to GH_TOKEN. If protected branches prevent pushes, create a RELEASE_PAT in repo secrets."
            echo "AUTO_TOKEN=${GH_TOKEN:-}" >> "$GITHUB_ENV"
          fi

      - name: Create release (compute version + changelog, call GitHub API)
        env:
          # Expose repo context and token; AUTO_TOKEN is written to $GITHUB_ENV in the previous step
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_SHA: ${{ github.sha }}
          OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail

          # (Diagnostics removed) no files are written by this workflow run.
          # Compute candidate via auto
          # Make the chosen token available as GH_TOKEN for auto and guard the
          # invocation so failures do not abort the whole job.
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"

          # Ensure git identity is configured before invoking `auto` which may
          # create temporary commits during dry-run. Without this auto can fail
          # with "Could not find a git name and email to commit with".
          git config user.name "github-actions[bot]" || true
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com" || true

          # Initialize variables to avoid 'unbound variable' when set -u is used
          CANDIDATE=""
          RAW_VERSION=""

          # Run auto and capture full output for diagnostics (don't print secrets)
            # Prefer using `auto shipit --dry-run` to get the full semver (vX.Y.Z)
            AUTO_SHIPIT_OUTPUT=$(npx auto shipit --dry-run 2>&1 || true)
            if [ -n "$(printf '%s' "$AUTO_SHIPIT_OUTPUT" | tr -d '[:space:]')" ]; then
              echo "---- auto shipit dry-run output ----"
              printf '%s\n' "$AUTO_SHIPIT_OUTPUT"
              echo "---- end auto shipit output ----"
            else
              echo "auto shipit produced no output or failed (non-fatal)"
            fi

            # Try to extract a semver (v1.2.3 or 1.2.3) from the shipit output
            # Some versions of auto print messages like:
            #   "Would have created a release on GitHub for version: 0.1.24"
            # or
            #   "Would have published: 0.1.19"
            # so grep for the first semver-like token and prefer that as CANDIDATE.
            CANDIDATE=$(printf '%s' "$AUTO_SHIPIT_OUTPUT" | grep -E -o 'v?[0-9]+\.[0-9]+\.[0-9]+' | head -n1 || true)

            # Ensure we have commits and tags from origin so CHANGELOG/RANGE calculations work
            git fetch --tags origin main || true
            LATEST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
            if [ -n "${LATEST_TAG:-}" ]; then
              RANGE="${LATEST_TAG}..origin/main"
            else
              RANGE="origin/main"
            fi

          if [ -n "$CANDIDATE" ]; then
            # Normalize tag name to start with 'v'
            case "$CANDIDATE" in
              v*) TAG_NAME="$CANDIDATE" ;;
              *) TAG_NAME="v$CANDIDATE" ;;
            esac
              echo "Computed candidate tag from auto: $TAG_NAME"
          else
            # auto failed or returned unexpected output (e.g. gitlog crash).
            # Fall back to a conservative git-based patch bump so releases
            # continue instead of failing the workflow.
            echo "Warning: 'auto shipit --dry-run' did not return a semver; falling back to git-based bump" >&2
            printf '%s\n' "${RAW_VERSION:-}" >&2 || true
            if [ -n "${LATEST_TAG:-}" ]; then
              BASE=${LATEST_TAG#v}
              IFS='.' read -r MAJOR MINOR PATCH <<< "${BASE}"
              MAJOR=${MAJOR:-0}
              MINOR=${MINOR:-0}
              PATCH=${PATCH:-0}
              PATCH=$((PATCH+1))
              TAG_NAME="v${MAJOR}.${MINOR}.${PATCH}"
            else
              # No prior tag found, start at v0.1.0 by default
              TAG_NAME="v0.1.0"
            fi
            echo "Fallback candidate tag: $TAG_NAME"
          fi

          echo "Computed candidate tag: $TAG_NAME"

          # We no longer perform a manual package.json bump in CI. Let `auto`
          # perform the version bump and publish atomically via `auto shipit`.
          echo "Skipping manual package.json bump; letting 'auto shipit' perform the bump & publish."
          # Ensure git identity is configured in case auto creates local commits
          git config user.name "${GITHUB_ACTOR:-github-actions[bot]}" || true
          git config user.email "${GITHUB_ACTOR:-github-actions[bot]}@users.noreply.github.com" || true

          # Build a changelog from git history between the last tag and origin/main
          echo "Building changelog for range: $RANGE"
          CHANGELOG=$(git --no-pager log "$RANGE" --pretty=format:"- %s (%an, %h)%n%n%b%n")
          if [ -z "$CHANGELOG" ]; then
            CHANGELOG="No changelog entries generated by git log for range $RANGE"
          fi

          # Create the release using `auto shipit` now that package.json has been bumped
          echo "Running 'auto shipit' to publish the release for ${TAG_NAME}"
          export GH_TOKEN="${AUTO_TOKEN:-${GH_TOKEN:-}}"
          # Run auto shipit (non-dry) to create the tag/release on GitHub. It will operate
          # against the repo and create the release referencing the current HEAD (the bumped commit).
          npx auto shipit || {
            echo "auto shipit failed; aborting release step" >&2
            exit 1
          }
