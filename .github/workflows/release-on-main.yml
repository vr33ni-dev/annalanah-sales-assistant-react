name: Release (create git tag) on merge to main

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  pull_request:
    types: [closed]
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      run_release: ${{ steps.check.outputs.run_release }}
    steps:
      - name: Check whether this run should perform the release
        id: check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const eventName = process.env.GITHUB_EVENT_NAME || ''
            const eventPath = process.env.GITHUB_EVENT_PATH || ''

            // Trigger release when a PR targeting main was merged.
            if (eventName === 'pull_request' && eventPath) {
              const payload = require(eventPath)
              const pr = payload.pull_request || {}
              const merged = !!pr.merged
              const baseRef = pr.base && pr.base.ref ? pr.base.ref : ''
                if (merged && baseRef === 'main') {
                  core.info('Pull request merged to main — checking whether a release/tag already exists for the merged commit')
                  // If the PR contains a merge_commit_sha, try to read package.json at
                  // that exact commit and skip the run if a matching tag/release already
                  // exists. This avoids the PR-triggered run doing bump/tag work when a
                  // nearly-simultaneous push-run already created the release.
                  try {
                    const mergeSha = pr.merge_commit_sha || null
                    if (mergeSha) {
                      let version = null
                      try {
                        const pkg = await github.rest.repos.getContent({ owner: payload.repository.owner.login, repo: payload.repository.name, path: 'package.json', ref: mergeSha })
                        const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                        const parsed = JSON.parse(content || '{}')
                        version = parsed.version || null
                      } catch (e) {
                        core.info('Could not read package.json at merge commit; will proceed with release run as fallback')
                      }

                      if (version) {
                        const tag = `v${version}`
                        try {
                          await github.rest.repos.getReleaseByTag({ owner: payload.repository.owner.login, repo: payload.repository.name, tag })
                          core.info(`Release for ${tag} already exists — skipping release run for merged PR.`)
                          core.setOutput('run_release','false')
                          return
                        } catch (e) {
                          // Not found — continue to check refs
                        }

                        try {
                          await github.rest.git.getRef({ owner: payload.repository.owner.login, repo: payload.repository.name, ref: `refs/tags/${tag}` })
                          core.info(`Tag ${tag} already exists — skipping release run for merged PR.`)
                          core.setOutput('run_release','false')
                          return
                        } catch (e) {
                          // Tag not found — proceed
                        }
                      }
                    }
                  } catch (err) {
                    core.info('Error while checking tags/releases for merged PR; proceeding with release run as a safe fallback.')
                  }
                  core.info('Pull request merged to main — proceeding with release run.')
                  core.setOutput('run_release','true')
                  return
                }
                core.info('Pull request closed but not a merged to main event — skipping release run.')
                core.setOutput('run_release','false')
                return
            }

            // For pushes, run only for pushes to main and only when a release/tag for the
            // package.json version is not already present on the repo. This covers the
            // GitHub behavior where merges that change workflow files may not trigger
            // the pull_request workflow run: the push event will act as a fallback.
            if (eventName === 'push') {
              const ref = process.env.GITHUB_REF || ''
              if (ref !== 'refs/heads/main') {
                core.info('Push event is not to main — skipping')
                core.setOutput('run_release','false')
                return
              }

              core.info('Push to main detected — checking for existing release/tag to avoid duplicate runs')
              try {
                const [owner, repo] = (process.env.GITHUB_REPOSITORY || '').split('/')
                const sha = process.env.GITHUB_SHA || ''

                // Try to read package.json at the pushed commit to derive the version
                let version = null
                try {
                  const pkg = await github.rest.repos.getContent({ owner, repo, path: 'package.json', ref: sha })
                  const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                  const parsed = JSON.parse(content || '{}')
                  version = parsed.version || null
                } catch (e) {
                  core.info('Could not read package.json at pushed commit; will proceed with release run as a fallback')
                }

                if (version) {
                  const tag = `v${version}`
                  // If a Release already exists for this tag, skip
                  try {
                    await github.rest.repos.getReleaseByTag({ owner, repo, tag })
                    core.info(`Release for ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Not found — continue to check refs
                  }

                  try {
                    await github.rest.git.getRef({ owner, repo, ref: `refs/tags/${tag}` })
                    core.info(`Tag ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Tag not found — proceed
                  }
                }

                core.info('No existing release/tag detected for pushed commit — proceeding with release run.')
                // Before deciding to run, check whether this push corresponds to a
                // PR merge and whether a pull_request-triggered release run already
                // executed for that merge. If so, skip the push-run to avoid a
                // duplicate release execution.
                try {
                  // Query PRs associated with the pushed commit (may be empty)
                  const prsResp = await github.request('GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls', { owner, repo, commit_sha: sha })
                  const prs = prsResp.data || []
                  const mergedPr = prs.find(p => p.base && p.base.ref === 'main' && p.merged_at)
                  if (mergedPr && mergedPr.number) {
                    core.info(`Push commit ${sha} is associated with merged PR #${mergedPr.number}; checking for a pull_request-triggered release run.`)
                    // Poll briefly for a pull_request-triggered run of this workflow for the same head SHA.
                    // Race conditions can occur where the push event fires before the PR-triggered run
                    // is created; wait a short time (up to ~30s) for that run to appear before
                    // deciding to proceed with the push-run fallback.
                    let skipped = false
                    const maxAttempts = 6
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                      try {
                        const wfResp = await github.request('GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs', { owner, repo, workflow_id: 'release-on-main.yml', head_sha: sha, event: 'pull_request', per_page: 1 })
                        const runs = (wfResp.data && wfResp.data.workflow_runs) || []
                        if (runs.length > 0) {
                          const run = runs[0]
                          core.info(`Found pull_request-triggered release workflow run for head ${sha} (id=${run.id}, status=${run.status}, conclusion=${run.conclusion})`)
                          // Only skip the push-run if the PR-run completed successfully.
                          if (run.conclusion === 'success') {
                            core.info(`PR-run concluded successfully (id=${run.id}) — skipping push-run.`)
                            core.setOutput('run_release','false')
                            skipped = true
                            break
                          }
                          // If the PR-run is still in progress or queued, wait and retry
                          if (run.status === 'in_progress' || run.status === 'queued') {
                            core.info('PR-run still in progress; waiting briefly for completion before deciding.')
                          } else {
                            // PR-run finished but did not succeed — do not skip
                            core.info('PR-run finished but did not succeed; will not skip push-run.')
                            break
                          }
                        }
                      } catch (e) {
                        core.info('Error checking for pull_request runs; will retry briefly.')
                      }
                      // wait 5s before next attempt
                      await new Promise(resolve => setTimeout(resolve, 5000))
                    }
                    if (skipped) return
                  }
                } catch (e) {
                  core.info('Error while checking for an existing pull_request run for this push; proceeding with release run as fallback.')
                }

                core.setOutput('run_release','true')
                return
              } catch (err) {
                core.info('Error while checking tags/releases for push; proceeding to run release as a safe fallback.')
                core.setOutput('run_release','true')
                return
              }
            }

            // Allow manual workflow dispatch
            if (eventName === 'workflow_dispatch') {
              core.info('Manual dispatch — proceeding with release run.')
              core.setOutput('run_release','true')
              return
            }

            core.info('Event not eligible for release run — skipping')
            core.setOutput('run_release','false')

  create_tag:
    needs: precheck
    concurrency:
      group: release-on-main-${{ github.ref }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Stop early if precheck decided not to run
        run: |
          if [ "${{ needs.precheck.outputs.run_release }}" != "true" ]; then
            echo "Precheck decided not to run release; stopping job."
            exit 0
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run consolidated release script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          chmod +x .github/scripts/release-on-main.sh || true
          ./.github/scripts/release-on-main.sh

          # List commit subjects only (no bodies), include short hash and author
          git --no-pager log ${RANGE} --pretty=format:"- %s (%an, %h)" >> ${CHANGELOG_FILE} || true

          # If no commits were listed, add a helpful note
          if [ ! -s ${CHANGELOG_FILE} ] || [ "$(wc -c < ${CHANGELOG_FILE})" -le 0 ]; then
            echo "    (no commits found)" >> ${CHANGELOG_FILE}
          fi

          echo "Changelog generated at ${CHANGELOG_FILE}"
          cat ${CHANGELOG_FILE}

      - name: Create GitHub release (optional)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          CHANGELOG_FILE=/tmp/changelog.md
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases"

          # Determine the target commit and derive the tag from package.json at that commit
          git fetch origin --tags || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping release creation"
            # Post a comment to the PR (if available) so maintainers see why release was skipped
            if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
              if [ -n "${PR_NUM}" ]; then
                MSG="Release skipped: package.json not found at target commit ${TARGET_COMMIT}. Please ensure the bumped package.json was merged to main."
                curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
              fi
            fi
            exit 0
          fi

          # Ensure the tag exists on remote before creating a Release
          if ! git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} not found on remote; attempting to create tag ref via API"
            # attempt to create the tag ref pointing to TARGET_COMMIT via API (fallback when git push tags fails)
            API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/git/refs"
            REF_PAYLOAD=$(jq -nc --arg ref "refs/tags/${TAG_FROM_PKG}" --arg sha "${TARGET_COMMIT}" '{ref:$ref, sha:$sha}')
            CREATE_RESP=$(curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$REF_PAYLOAD" "$API_URL" || true)
            if echo "$CREATE_RESP" | jq -e .ref >/dev/null 2>&1; then
              echo "Created tag ref ${TAG_FROM_PKG} -> ${TARGET_COMMIT} via API"
            else
              echo "Failed to create tag ref via API; response: $CREATE_RESP" >&2
              # Post a comment to the PR so maintainers know a tag wasn't found
              if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
                PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
                if [ -n "${PR_NUM}" ]; then
                  MSG="Release skipped: tag ${TAG_FROM_PKG} not found on remote and API creation failed. The tag-step may have been skipped or branch protections prevented pushing the bump. Please merge the bump commit or create the tag manually."
                  curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
                fi
              fi
              exit 0
            fi
          fi

          # Use the tag as the Release name/title. Put the PR title (if available)
          # as the first line of the release body so the release page shows the
          # version as the title and the PR title as the lead line in the body.
          RELEASE_NAME="${TAG_FROM_PKG}"

          # Try to determine a PR title to include in the release body. Prefer the
          # event payload (works for pull_request-triggered runs), otherwise look up
          # PRs associated with the target commit.
          PR_TITLE=""
          PR_NUM=""
          if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
            PR_TITLE=$(jq -r '.pull_request.title // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
            PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
          fi

          if [ -z "${PR_TITLE}" ]; then
            PRS=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github.groot-preview+json" "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${TARGET_COMMIT}/pulls" || true)
            PR_TITLE=$(echo "$PRS" | jq -r '.[0].title // empty' 2>/dev/null || true)
            PR_NUM=$(echo "$PRS" | jq -r '.[0].number // empty' 2>/dev/null || true)
          fi

          # Build a leading PR line if we have a title/number
          PR_LEAD_LINE=""
          if [ -n "${PR_TITLE}" ]; then
            if [ -n "${PR_NUM}" ]; then
              PR_LEAD_LINE="Merge PR #${PR_NUM}: ${PR_TITLE}"
            else
              PR_LEAD_LINE="${PR_TITLE}"
            fi
          fi

          # Compose release body: PR lead line (if any) followed by the generated changelog.
          # The changelog currently includes the tag as its first line; 
          RAW_CHANGELOG=$(cat ${CHANGELOG_FILE} 2>/dev/null || true)
          # Keep the changelog intact (including the leading tag line). This
          # makes the release body start with the tag/version header as you
          # requested.
          CHANGELOG_BODY="${RAW_CHANGELOG}"

          # Use the changelog as the release body directly. The changelog file
          # already includes the tag as the first line and (for pull_request
          # runs) the PR title is included in the changelog so the release
          # body will match the example format you provided.
          BODY_CONTENT="${CHANGELOG_BODY}"

          BODY=$(jq -nc --arg tag "$TAG_FROM_PKG" --arg name "$RELEASE_NAME" --arg body "$BODY_CONTENT" '{tag_name:$tag, name:$name, body:$body, draft:false, prerelease:false}')
          echo "Creating release for ${TAG_FROM_PKG}"
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$BODY" "$API_URL" >/dev/null

  bump_dry_run:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dry-run bump (manual)
        id: dryrun
        env:
          PR_LABELS: ""
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          ./.github/scripts/bump-version.sh package.json auto --dry-run
