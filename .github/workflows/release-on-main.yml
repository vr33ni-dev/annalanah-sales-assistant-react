name: Release (create git tag) on merge to main

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  pull_request:
    types: [closed]
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      run_release: ${{ steps.check.outputs.run_release }}
    steps:
      - name: Check whether this run should perform the release
        id: check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const eventName = process.env.GITHUB_EVENT_NAME || ''
            const eventPath = process.env.GITHUB_EVENT_PATH || ''

            // Trigger release when a PR targeting main was merged.
            if (eventName === 'pull_request' && eventPath) {
              const payload = require(eventPath)
              const pr = payload.pull_request || {}
              const merged = !!pr.merged
              const baseRef = pr.base && pr.base.ref ? pr.base.ref : ''
              if (merged && baseRef === 'main') {
                core.info('Pull request merged to main — proceeding with release run.')
                core.setOutput('run_release','true')
                return
              }
              core.info('Pull request closed but not a merged to main event — skipping release run.')
              core.setOutput('run_release','false')
              return
            }

            // For pushes, run only for pushes to main and only when a release/tag for the
            // package.json version is not already present on the repo. This covers the
            // GitHub behavior where merges that change workflow files may not trigger
            // the pull_request workflow run: the push event will act as a fallback.
            if (eventName === 'push') {
              const ref = process.env.GITHUB_REF || ''
              if (ref !== 'refs/heads/main') {
                core.info('Push event is not to main — skipping')
                core.setOutput('run_release','false')
                return
              }

              core.info('Push to main detected — checking for existing release/tag to avoid duplicate runs')
              try {
                const [owner, repo] = (process.env.GITHUB_REPOSITORY || '').split('/')
                const sha = process.env.GITHUB_SHA || ''

                // Try to read package.json at the pushed commit to derive the version
                let version = null
                try {
                  const pkg = await github.rest.repos.getContent({ owner, repo, path: 'package.json', ref: sha })
                  const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                  const parsed = JSON.parse(content || '{}')
                  version = parsed.version || null
                } catch (e) {
                  core.info('Could not read package.json at pushed commit; will proceed with release run as a fallback')
                }

                if (version) {
                  const tag = `v${version}`
                  // If a Release already exists for this tag, skip
                  try {
                    await github.rest.repos.getReleaseByTag({ owner, repo, tag })
                    core.info(`Release for ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Not found — continue to check refs
                  }

                  try {
                    await github.rest.git.getRef({ owner, repo, ref: `refs/tags/${tag}` })
                    core.info(`Tag ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Tag not found — proceed
                  }
                }

                core.info('No existing release/tag detected for pushed commit — proceeding with release run.')
                core.setOutput('run_release','true')
                return
              } catch (err) {
                core.info('Error while checking tags/releases for push; proceeding to run release as a safe fallback.')
                core.setOutput('run_release','true')
                return
              }
            }

            // Allow manual workflow dispatch
            if (eventName === 'workflow_dispatch') {
              core.info('Manual dispatch — proceeding with release run.')
              core.setOutput('run_release','true')
              return
            }

            core.info('Event not eligible for release run — skipping')
            core.setOutput('run_release','false')

  create_tag:
    needs: precheck
    concurrency:
      group: release-on-main-${{ github.ref }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Stop early if precheck decided not to run
        run: |
          if [ "${{ needs.precheck.outputs.run_release }}" != "true" ]; then
            echo "Precheck decided not to run release; stopping job."
            exit 0
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Early guard — skip if tag/release exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          git fetch origin --tags || true

          # prefer origin/main as the target if available
          if git rev-parse --verify origin/main >/dev/null 2>&1; then
            TARGET_COMMIT=$(git rev-parse --verify origin/main)
          else
            TARGET_COMMIT=$(git rev-parse --verify HEAD)
          fi

          # try to read package.json version at the target commit
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG="v${TAG_VERSION}"

            # skip if tag already exists on remote
            if git ls-remote --exit-code --tags origin "refs/tags/${TAG}" >/dev/null 2>&1; then
              echo "Tag ${TAG} already exists on remote — skipping release job."
              exit 0
            fi

            # skip if a GitHub Release exists for this tag
            if curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
                 "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}" \
                 | jq -e .id >/dev/null 2>&1; then
              echo "Release for ${TAG} already exists — skipping release job."
              exit 0
            fi
          else
            echo "No package.json version found at ${TARGET_COMMIT}; continuing."
          fi

      # remaining steps follow

      - name: Fetch tags
        run: |
          git fetch --tags origin

      - id: require_labels
        name: Require release label on merged PRs
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          PR_LABELS_JSON="[]"

          # Try to find PRs associated with the commit (this is live data so re-runs see updated labels).
          PR_INFO=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" \
            -H "Accept: application/vnd.github.groot-preview+json" || true)

          PR_LABELS_JSON=$(echo "$PR_INFO" | jq -c '.[0].labels // empty' 2>/dev/null || true)

          # If we couldn't locate a PR from the commit (e.g., unusual event), fall back to event payload labels for pull_request events
          if [ -z "${PR_LABELS_JSON}" ] || [ "${PR_LABELS_JSON}" = "null" ]; then
            if [ "${GITHUB_EVENT_NAME}" = "pull_request" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_LABELS_JSON=$(jq -c '.pull_request.labels // []' "${GITHUB_EVENT_PATH}" 2>/dev/null || echo "[]")
            else
              PR_LABELS_JSON="[]"
            fi
          fi

          # expose PR_LABELS as a step output for downstream steps
          echo "PR_LABELS=${PR_LABELS_JSON}" >> "${GITHUB_OUTPUT}"

          LABEL_NAMES=$(echo "$PR_LABELS_JSON" | jq -r '.[].name' || true)
          if [ -z "$(echo "$LABEL_NAMES" | tr -d '[:space:]')" ]; then
            echo "ERROR: Merged PR does not have a release label (major/minor/patch)."
            exit 1
          fi
          echo "Found labels: $LABEL_NAMES"

      - name: Auto bump version (label-driven)
        if: ${{ github.event_name == 'pull_request' }}
        id: autobump
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          PR_LABELS: ${{ steps.require_labels.outputs.PR_LABELS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          BASE_REF: main
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          # run in apply mode so the script will modify package.json/VERSION as needed
          ./.github/scripts/bump-version.sh package.json auto --apply

      - name: Commit and push package.json (if changed)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          if git status --porcelain | grep -q '^'; then
            git add package.json package-lock.json || true
            # set git identity before committing to avoid author/identity errors on runners
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore(release): bump package.json version to $(jq -r .version package.json) [skip ci]" || true

            # Try to push directly to main
            if git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}" HEAD:main; then
              echo "Pushed package.json to origin/main with GITHUB_TOKEN"
            else
              echo "Push to origin/main failed with GITHUB_TOKEN. Attempting to update package.json via the GitHub Contents API (may work with branch protection)."

              # prepare base64 content of package.json (single-line)
              if command -v base64 >/dev/null 2>&1; then
                NEW_CONTENT_B64=$(base64 package.json | tr -d '\n')
              else
                NEW_CONTENT_B64=$(cat package.json | base64 | tr -d '\n')
              fi

              REMOTE_PATH="package.json"
              MSG="chore(release): bump package.json to $(jq -r .version package.json) [skip ci]"

              # get current remote file to obtain sha
              REMOTE_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${REMOTE_PATH}?ref=main" || true)
              REMOTE_SHA=$(echo "$REMOTE_JSON" | jq -r .sha 2>/dev/null || true)

              if [ -n "$REMOTE_SHA" ] && [ "$REMOTE_SHA" != "null" ]; then
                echo "Updating package.json on main via Contents API (sha=$REMOTE_SHA)"
                DATA=$(jq -n --arg message "$MSG" --arg content "$NEW_CONTENT_B64" --arg branch "main" --arg sha "$REMOTE_SHA" '{message:$message, content:$content, branch:$branch, sha:$sha}')
              else
                echo "Remote package.json not found or no sha; attempting to create via Contents API"
                DATA=$(jq -n --arg message "$MSG" --arg content "$NEW_CONTENT_B64" --arg branch "main" '{message:$message, content:$content, branch:$branch}')
              fi

              UPDATE_RESP=$(curl -s -X PUT -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$DATA" "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${REMOTE_PATH}" || true)
              if echo "$UPDATE_RESP" | jq -e .content >/dev/null 2>&1; then
                echo "Successfully updated package.json on main via Contents API"
              else
                echo "Contents API update failed; cannot auto-apply bump due to branch protection. Response: $UPDATE_RESP" >&2
                # Instead of creating a fallback branch/PR (which may be blocked by org policy),
                # post an explanatory comment on the merged PR so maintainers can take action.
                if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
                  PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
                  if [ -n "$PR_NUM" ]; then
                    MSG="Automated release bump could not be applied to \`main\` due to branch protection. I attempted to update package.json to $(jq -r .version package.json) but the update was rejected. Please merge the bump into main (or allow Actions to create PRs) so the release can proceed."
                    echo "Posting note to PR #${PR_NUM}: $MSG"
                    curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
                  else
                    echo "No PR number found in event payload; cannot post explanatory comment."
                  fi
                else
                  echo "No event payload available; cannot post PR comment explaining blocked update."
                fi
                # Do not fail the job here. Instead record that the bump was not applied
                # so downstream steps can still create a tag/release based on the computed
                # version. This avoids failing the whole release when branch protection
                # prevents actions from pushing to main.
                echo "BUMP_APPLY_FAILED=1" >> "$GITHUB_ENV"
                echo "Continuing release run: will attempt to create tag/release without updating package.json on main."
              fi
            fi
          else
            echo "No changes to commit"
          fi

      - name: Create v-tag and push (if package.json version)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          # fetch tags and remote main
          git fetch origin --tags

          # compute target commit: prefer origin/main (the pushed commit), otherwise local HEAD
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            echo "Local HEAD ($LOCAL_HEAD) differs from origin/main ($REMOTE_MAIN); tagging origin/main instead."
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          # derive tag from package.json at the target commit to ensure it matches the bumped version
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping tag creation"
            exit 0
          fi

          # check remote for existing tag
          if git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} already exists on remote; skipping tag creation."
            exit 0
          fi

          # create annotated tag at the target commit and push
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git tag -a "${TAG_FROM_PKG}" "$TARGET_COMMIT" -m "Release ${TAG_FROM_PKG}"
          if git push origin "refs/tags/${TAG_FROM_PKG}"; then
            echo "Pushed tag ${TAG_FROM_PKG} -> ${TARGET_COMMIT}"
          else
            echo "git push of tag ${TAG_FROM_PKG} failed; attempting to create tag ref via GitHub API"
            # Create a lightweight tag ref via the GitHub API as a fallback
            API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/git/refs"
            REF_PAYLOAD=$(jq -nc --arg ref "refs/tags/${TAG_FROM_PKG}" --arg sha "$TARGET_COMMIT" '{ref:$ref, sha:$sha}')
            CREATE_RESP=$(curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$REF_PAYLOAD" "$API_URL" || true)
            if echo "$CREATE_RESP" | jq -e .ref >/dev/null 2>&1; then
              echo "Created tag ref ${TAG_FROM_PKG} -> ${TARGET_COMMIT} via API"
            else
              echo "Failed to create tag ref via API; response: $CREATE_RESP" >&2
              echo "Tag creation failed; skipping tag push step."
            fi
          fi

      - name: Generate changelog
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          EVENT_NAME=${GITHUB_EVENT_NAME:-}
          CHANGELOG_FILE=/tmp/changelog.md
          echo "" > ${CHANGELOG_FILE}

          # Determine target commit (prefer origin/main)
          git fetch origin --tags origin main || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          # Use package.json at target commit for the version header when available
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            echo "v${TAG_VERSION}" >> ${CHANGELOG_FILE}
            echo "" >> ${CHANGELOG_FILE}
          fi

          # If this was a pull_request event, include the PR title (no body)
          if [ "${EVENT_NAME}" = "pull_request" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
            PR_NUM=$(jq -r '.pull_request.number' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
            PR_TITLE=$(jq -r '.pull_request.title' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
            if [ -n "${PR_NUM}" ] && [ "${PR_NUM}" != "null" ]; then
              echo "Merge PR #${PR_NUM}: ${PR_TITLE}" >> ${CHANGELOG_FILE}
              echo "" >> ${CHANGELOG_FILE}
            fi
          fi

          # Determine last tag and list commits since that tag
          LAST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
          if [ -z "${LAST_TAG}" ]; then
            echo "Changes:" >> ${CHANGELOG_FILE}
            RANGE="${TARGET_COMMIT}"
          else
            echo "Changes since ${LAST_TAG}:" >> ${CHANGELOG_FILE}
            RANGE="${LAST_TAG}..${TARGET_COMMIT}"
          fi

          # List commit subjects and authors
          git --no-pager log ${RANGE} --pretty=format:"    %s (%an)" >> ${CHANGELOG_FILE} || true

          # If no commits were listed, add a helpful note
          if [ ! -s ${CHANGELOG_FILE} ] || [ "$(wc -c < ${CHANGELOG_FILE})" -le 0 ]; then
            echo "    (no commits found)" >> ${CHANGELOG_FILE}
          fi

          echo "Changelog generated at ${CHANGELOG_FILE}"
          cat ${CHANGELOG_FILE}

      - name: Create GitHub release (optional)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          CHANGELOG_FILE=/tmp/changelog.md
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases"

          # Determine the target commit and derive the tag from package.json at that commit
          git fetch origin --tags || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping release creation"
            # Post a comment to the PR (if available) so maintainers see why release was skipped
            if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
              if [ -n "${PR_NUM}" ]; then
                MSG="Release skipped: package.json not found at target commit ${TARGET_COMMIT}. Please ensure the bumped package.json was merged to main."
                curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
              fi
            fi
            exit 0
          fi

          # Ensure the tag exists on remote before creating a Release
          if ! git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} not found on remote; attempting to create tag ref via API"
            # attempt to create the tag ref pointing to TARGET_COMMIT via API (fallback when git push tags fails)
            API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/git/refs"
            REF_PAYLOAD=$(jq -nc --arg ref "refs/tags/${TAG_FROM_PKG}" --arg sha "${TARGET_COMMIT}" '{ref:$ref, sha:$sha}')
            CREATE_RESP=$(curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$REF_PAYLOAD" "$API_URL" || true)
            if echo "$CREATE_RESP" | jq -e .ref >/dev/null 2>&1; then
              echo "Created tag ref ${TAG_FROM_PKG} -> ${TARGET_COMMIT} via API"
            else
              echo "Failed to create tag ref via API; response: $CREATE_RESP" >&2
              # Post a comment to the PR so maintainers know a tag wasn't found
              if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
                PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
                if [ -n "${PR_NUM}" ]; then
                  MSG="Release skipped: tag ${TAG_FROM_PKG} not found on remote and API creation failed. The tag-step may have been skipped or branch protections prevented pushing the bump. Please merge the bump commit or create the tag manually."
                  curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
                fi
              fi
              exit 0
            fi
          fi

          BODY=$(jq -nc --arg tag "$TAG_FROM_PKG" --arg body "$(cat ${CHANGELOG_FILE} 2>/dev/null || true)" '{tag_name:$tag, name:$tag, body:$body, draft:false, prerelease:false}')
          echo "Creating release for ${TAG_FROM_PKG}"
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$BODY" "$API_URL" >/dev/null

  bump_dry_run:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dry-run bump (manual)
        id: dryrun
        env:
          PR_LABELS: ""
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          ./.github/scripts/bump-version.sh package.json auto --dry-run
