name: Release (create git tag) on merge to main

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  pull_request:
    types: [closed]
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      run_release: ${{ steps.check.outputs.run_release }}
    steps:
      - name: Check whether this run should perform the release
        id: check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const eventName = process.env.GITHUB_EVENT_NAME || ''
            const eventPath = process.env.GITHUB_EVENT_PATH || ''

            // Trigger release when a PR targeting main was merged.
            if (eventName === 'pull_request' && eventPath) {
              const payload = require(eventPath)
              const pr = payload.pull_request || {}
              const merged = !!pr.merged
              const baseRef = pr.base && pr.base.ref ? pr.base.ref : ''
                if (merged && baseRef === 'main') {
                  core.info('Pull request merged to main — checking whether a release/tag already exists for the merged commit')
                  // If the PR contains a merge_commit_sha, try to read package.json at
                  // that exact commit and skip the run if a matching tag/release already
                  // exists. This avoids the PR-triggered run doing bump/tag work when a
                  // nearly-simultaneous push-run already created the release.
                  try {
                    const mergeSha = pr.merge_commit_sha || null
                    if (mergeSha) {
                      let version = null
                      try {
                        const pkg = await github.rest.repos.getContent({ owner: payload.repository.owner.login, repo: payload.repository.name, path: 'package.json', ref: mergeSha })
                        const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                        const parsed = JSON.parse(content || '{}')
                        version = parsed.version || null
                      } catch (e) {
                        core.info('Could not read package.json at merge commit; will proceed with release run as fallback')
                      }

                      if (version) {
                        const tag = `v${version}`
                        try {
                          await github.rest.repos.getReleaseByTag({ owner: payload.repository.owner.login, repo: payload.repository.name, tag })
                          core.info(`Release for ${tag} already exists — skipping release run for merged PR.`)
                          core.setOutput('run_release','false')
                          return
                        } catch (e) {
                          // Not found — continue to check refs
                        }

                        try {
                          await github.rest.git.getRef({ owner: payload.repository.owner.login, repo: payload.repository.name, ref: `refs/tags/${tag}` })
                          core.info(`Tag ${tag} already exists — skipping release run for merged PR.`)
                          core.setOutput('run_release','false')
                          return
                        } catch (e) {
                          // Tag not found — proceed
                        }
                      }
                    }
                  } catch (err) {
                    core.info('Error while checking tags/releases for merged PR; proceeding with release run as a safe fallback.')
                  }
                  core.info('Pull request merged to main — proceeding with release run.')
                  core.setOutput('run_release','true')
                  return
                }
                core.info('Pull request closed but not a merged to main event — skipping release run.')
                core.setOutput('run_release','false')
                return
            }

            // For pushes, run only for pushes to main and only when a release/tag for the
            // package.json version is not already present on the repo. This covers the
            // GitHub behavior where merges that change workflow files may not trigger
            // the pull_request workflow run: the push event will act as a fallback.
            if (eventName === 'push') {
              const ref = process.env.GITHUB_REF || ''
              if (ref !== 'refs/heads/main') {
                core.info('Push event is not to main — skipping')
                core.setOutput('run_release','false')
                return
              }

              core.info('Push to main detected — checking for existing release/tag to avoid duplicate runs')
              try {
                const [owner, repo] = (process.env.GITHUB_REPOSITORY || '').split('/')
                const sha = process.env.GITHUB_SHA || ''

                // Try to read package.json at the pushed commit to derive the version
                let version = null
                try {
                  const pkg = await github.rest.repos.getContent({ owner, repo, path: 'package.json', ref: sha })
                  const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                  const parsed = JSON.parse(content || '{}')
                  version = parsed.version || null
                } catch (e) {
                  core.info('Could not read package.json at pushed commit; will proceed with release run as a fallback')
                }

                if (version) {
                  const tag = `v${version}`
                  // If a Release already exists for this tag, skip
                  try {
                    await github.rest.repos.getReleaseByTag({ owner, repo, tag })
                    core.info(`Release for ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Not found — continue to check refs
                  }

                  try {
                    await github.rest.git.getRef({ owner, repo, ref: `refs/tags/${tag}` })
                    core.info(`Tag ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Tag not found — proceed
                  }
                }

                core.info('No existing release/tag detected for pushed commit — proceeding with release run.')
                // Before deciding to run, check whether this push corresponds to a
                // PR merge and whether a pull_request-triggered release run already
                // executed for that merge. If so, skip the push-run to avoid a
                // duplicate release execution.
                try {
                  // Query PRs associated with the pushed commit (may be empty)
                  const prsResp = await github.request('GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls', { owner, repo, commit_sha: sha })
                  const prs = prsResp.data || []
                  const mergedPr = prs.find(p => p.base && p.base.ref === 'main' && p.merged_at)
                  if (mergedPr && mergedPr.number) {
                    core.info(`Push commit ${sha} is associated with merged PR #${mergedPr.number}; checking for a pull_request-triggered release run.`)
                    // Poll briefly for a pull_request-triggered run of this workflow for the same head SHA.
                    // Race conditions can occur where the push event fires before the PR-triggered run
                    // is created; wait a short time (up to ~30s) for that run to appear before
                    // deciding to proceed with the push-run fallback.
                    let skipped = false
                    const maxAttempts = 6
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                      try {
                        const wfResp = await github.request('GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs', { owner, repo, workflow_id: 'release-on-main.yml', head_sha: sha, event: 'pull_request', per_page: 1 })
                        const runs = (wfResp.data && wfResp.data.workflow_runs) || []
                        if (runs.length > 0) {
                          const run = runs[0]
                          core.info(`Found pull_request-triggered release workflow run for head ${sha} (id=${run.id}, status=${run.status}, conclusion=${run.conclusion})`)
                          // Only skip the push-run if the PR-run completed successfully.
                          if (run.conclusion === 'success') {
                            core.info(`PR-run concluded successfully (id=${run.id}) — skipping push-run.`)
                            core.setOutput('run_release','false')
                            skipped = true
                            break
                          }
                          // If the PR-run is still in progress or queued, wait and retry
                          if (run.status === 'in_progress' || run.status === 'queued') {
                            core.info('PR-run still in progress; waiting briefly for completion before deciding.')
                          } else {
                            // PR-run finished but did not succeed — do not skip
                            core.info('PR-run finished but did not succeed; will not skip push-run.')
                            break
                          }
                        }
                      } catch (e) {
                        core.info('Error checking for pull_request runs; will retry briefly.')
                      }
                      // wait 5s before next attempt
                      await new Promise(resolve => setTimeout(resolve, 5000))
                    }
                    if (skipped) return
                  }
                } catch (e) {
                  core.info('Error while checking for an existing pull_request run for this push; proceeding with release run as fallback.')
                }

                core.setOutput('run_release','true')
                return
              } catch (err) {
                core.info('Error while checking tags/releases for push; proceeding to run release as a safe fallback.')
                core.setOutput('run_release','true')
                return
              }
            }

            // Allow manual workflow dispatch
            if (eventName === 'workflow_dispatch') {
              core.info('Manual dispatch — proceeding with release run.')
              core.setOutput('run_release','true')
              return
            }

            core.info('Event not eligible for release run — skipping')
            core.setOutput('run_release','false')

  create_tag:
    needs: precheck
    concurrency:
      group: release-on-main-${{ github.ref }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Stop early if precheck decided not to run
        run: |
          if [ "${{ needs.precheck.outputs.run_release }}" != "true" ]; then
            echo "Precheck decided not to run release; stopping job."
            exit 0
          fi

      - name: If push originated from a merged PR, skip only if PR-run already executed (avoid duplicate run)
        if: ${{ github.event_name == 'push' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          echo "Checking whether push ${GITHUB_SHA} corresponds to a merged PR..."
          PRS=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github.groot-preview+json" "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" || true)
          if [ -z "${PRS}" ] || [ "${PRS}" = "null" ]; then
            echo "No PRs associated with commit ${GITHUB_SHA}."
            exit 0
          fi
          # find any PR merged into main
          MERGED_PR_NUM=$(echo "$PRS" | jq -r '.[] | select(.base.ref=="main" and (.merged_at // empty) != "") | .number' | head -n1 || true)
          if [ -z "${MERGED_PR_NUM}" ]; then
            echo "No merged PR found for this commit (or merged PR not into main) — continuing."
            exit 0
          fi

          echo "Found merged PR #${MERGED_PR_NUM} for commit ${GITHUB_SHA}; checking for a pull_request-triggered workflow run..."

          # Check whether a pull_request-triggered run for the release workflow was created for this commit.
          # If such a run exists (i.e., the PR merge triggered the release workflow), skip the duplicate push-run.
          # Otherwise, continue so the push-run acts as a fallback when the PR merge didn't trigger a run.
          RUNS_API="https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/workflows/release-on-main.yml/runs?head_sha=${GITHUB_SHA}&event=pull_request&per_page=1"
          RUNS_RESP=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "$RUNS_API" || true)
          COUNT=$(echo "$RUNS_RESP" | jq -r '.total_count // 0' 2>/dev/null || echo 0)
          if [ "${COUNT}" -gt 0 ]; then
            echo "Found a pull_request-triggered release workflow run for this commit (count=${COUNT}) — assuming pull_request run handled the release; skipping duplicate push-run."
            exit 0
          else
            echo "No pull_request-triggered release workflow run found for this commit — continuing with push-run (fallback)."
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure origin remote exists
        run: |
          set -euo pipefail
          # Some runner checkout states may not populate an 'origin' remote in all cases
          # (or a previous edit accidentally removed it). Add it if missing so later
          # git fetch/origin commands do not fail with "couldn't find remote ref origin".
          if ! git remote | grep -q '^origin$'; then
            echo "Adding origin remote for ${GITHUB_REPOSITORY}"
            git remote add origin "https://github.com/${{ github.repository }}.git" || true
          else
            echo "origin remote already present"
          fi

      - name: Early guard — skip if tag/release exists
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          git fetch origin --tags || true

          # prefer origin/main as the target if available
          if git rev-parse --verify origin/main >/dev/null 2>&1; then
            TARGET_COMMIT=$(git rev-parse --verify origin/main)
          else
            TARGET_COMMIT=$(git rev-parse --verify HEAD)
          fi

          # try to read package.json version at the target commit
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG="v${TAG_VERSION}"

            # skip if tag already exists on remote
            if git ls-remote --exit-code --tags origin "refs/tags/${TAG}" >/dev/null 2>&1; then
              echo "Tag ${TAG} already exists on remote — skipping release job."
              exit 0
            fi

            # skip if a GitHub Release exists for this tag
            if curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
                 "https://api.github.com/repos/${GITHUB_REPOSITORY}/releases/tags/${TAG}" \
                 | jq -e .id >/dev/null 2>&1; then
              echo "Release for ${TAG} already exists — skipping release job."
              exit 0
            fi
          else
            echo "No package.json version found at ${TARGET_COMMIT}; continuing."
          fi

      # remaining steps follow

      - name: Fetch tags
        run: |
          git fetch --tags origin

      - id: require_labels
        name: Require release label on merged PRs
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          PR_LABELS_JSON="[]"

          # Try to find PRs associated with the commit (this is live data so re-runs see updated labels).
          PR_INFO=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" \
            -H "Accept: application/vnd.github.groot-preview+json" || true)

          PR_LABELS_JSON=$(echo "$PR_INFO" | jq -c '.[0].labels // empty' 2>/dev/null || true)

          # If we couldn't locate a PR from the commit (e.g., unusual event), fall back to event payload labels for pull_request events
          if [ -z "${PR_LABELS_JSON}" ] || [ "${PR_LABELS_JSON}" = "null" ]; then
            if [ "${GITHUB_EVENT_NAME}" = "pull_request" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_LABELS_JSON=$(jq -c '.pull_request.labels // []' "${GITHUB_EVENT_PATH}" 2>/dev/null || echo "[]")
            else
              PR_LABELS_JSON="[]"
            fi
          fi

          # expose PR_LABELS as a step output for downstream steps
          echo "PR_LABELS=${PR_LABELS_JSON}" >> "${GITHUB_OUTPUT}"

          LABEL_NAMES=$(echo "$PR_LABELS_JSON" | jq -r '.[].name' || true)
          if [ -z "$(echo "$LABEL_NAMES" | tr -d '[:space:]')" ]; then
            echo "ERROR: Merged PR does not have a release label (major/minor/patch)."
            exit 1
          fi
          echo "Found labels: $LABEL_NAMES"

      - name: Auto bump version (label-driven)
        if: ${{ github.event_name == 'pull_request' }}
        id: autobump
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          PR_LABELS: ${{ steps.require_labels.outputs.PR_LABELS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          BASE_REF: main
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          # run in apply mode so the script will modify package.json/VERSION as needed
          ./.github/scripts/bump-version.sh package.json auto --apply

      - name: Commit and push package.json (if changed)
        if: ${{ github.event_name == 'pull_request' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          if git status --porcelain | grep -q '^'; then
            git add package.json package-lock.json || true
            # set git identity before committing to avoid author/identity errors on runners
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore(release): bump package.json version to $(jq -r .version package.json) [skip ci]" || true

            # Try to push directly to main
            if git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}" HEAD:main; then
              echo "Pushed package.json to origin/main with GITHUB_TOKEN"
            else
              echo "Push to origin/main failed with GITHUB_TOKEN. Attempting to update package.json via the GitHub Contents API (may work with branch protection)."

              # prepare base64 content of package.json (single-line)
              if command -v base64 >/dev/null 2>&1; then
                NEW_CONTENT_B64=$(base64 package.json | tr -d '\n')
              else
                NEW_CONTENT_B64=$(cat package.json | base64 | tr -d '\n')
              fi

              REMOTE_PATH="package.json"
              MSG="chore(release): bump package.json to $(jq -r .version package.json) [skip ci]"

              # get current remote file to obtain sha
              REMOTE_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${REMOTE_PATH}?ref=main" || true)
              REMOTE_SHA=$(echo "$REMOTE_JSON" | jq -r .sha 2>/dev/null || true)

              if [ -n "$REMOTE_SHA" ] && [ "$REMOTE_SHA" != "null" ]; then
                echo "Updating package.json on main via Contents API (sha=$REMOTE_SHA)"
                DATA=$(jq -n --arg message "$MSG" --arg content "$NEW_CONTENT_B64" --arg branch "main" --arg sha "$REMOTE_SHA" '{message:$message, content:$content, branch:$branch, sha:$sha}')
              else
                echo "Remote package.json not found or no sha; attempting to create via Contents API"
                DATA=$(jq -n --arg message "$MSG" --arg content "$NEW_CONTENT_B64" --arg branch "main" '{message:$message, content:$content, branch:$branch}')
              fi

              UPDATE_RESP=$(curl -s -X PUT -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$DATA" "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${REMOTE_PATH}" || true)
              if echo "$UPDATE_RESP" | jq -e .content >/dev/null 2>&1; then
                echo "Successfully updated package.json on main via Contents API"
              else
                echo "Contents API update failed; cannot auto-apply bump due to branch protection. Response: $UPDATE_RESP" >&2
                # Post an explanatory comment on the merged PR so maintainers can take action.
                if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
                  PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
                  if [ -n "$PR_NUM" ]; then
                    MSG="Automated release bump could not be applied to \`main\` due to branch protection. I attempted to update package.json to $(jq -r .version package.json) but the update was rejected. Please merge the bump into main (or allow Actions to create PRs) so the release can proceed."
                    echo "Posting note to PR #${PR_NUM}: $MSG"
                    curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
                  else
                    echo "No PR number found in event payload; cannot post explanatory comment."
                  fi
                else
                  echo "No event payload available; cannot post PR comment explaining blocked update."
                fi
                # Do not fail the job here. Instead record that the bump was not applied
                # so downstream steps can still create a tag/release based on the computed
                # version. This avoids failing the whole release when branch protection
                # prevents actions from pushing to main.
                echo "BUMP_APPLY_FAILED=1" >> "$GITHUB_ENV"
                echo "Continuing release run: will attempt to create tag/release without updating package.json on main."
              fi
            fi
          else
            echo "No changes to commit"
          fi

      - name: Create v-tag and push (if package.json version)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          # fetch tags and remote main
          git fetch origin --tags

          # compute target commit: prefer origin/main (the pushed commit), otherwise local HEAD
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            echo "Local HEAD ($LOCAL_HEAD) differs from origin/main ($REMOTE_MAIN); tagging origin/main instead."
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          # derive tag from package.json at the target commit to ensure it matches the bumped version
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping tag creation"
            exit 0
          fi

          # check remote for existing tag
          if git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} already exists on remote; skipping tag creation."
            exit 0
          fi

          # create annotated tag at the target commit and push
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git tag -a "${TAG_FROM_PKG}" "$TARGET_COMMIT" -m "Release ${TAG_FROM_PKG}"
          if git push origin "refs/tags/${TAG_FROM_PKG}"; then
            echo "Pushed tag ${TAG_FROM_PKG} -> ${TARGET_COMMIT}"
          else
            echo "git push of tag ${TAG_FROM_PKG} failed; attempting to create tag ref via GitHub API"
            # Create a lightweight tag ref via the GitHub API as a fallback
            API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/git/refs"
            REF_PAYLOAD=$(jq -nc --arg ref "refs/tags/${TAG_FROM_PKG}" --arg sha "$TARGET_COMMIT" '{ref:$ref, sha:$sha}')
            CREATE_RESP=$(curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$REF_PAYLOAD" "$API_URL" || true)
            if echo "$CREATE_RESP" | jq -e .ref >/dev/null 2>&1; then
              echo "Created tag ref ${TAG_FROM_PKG} -> ${TARGET_COMMIT} via API"
            else
              echo "Failed to create tag ref via API; response: $CREATE_RESP" >&2
              echo "Tag creation failed; skipping tag push step."
            fi
          fi

      - name: Generate changelog
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          EVENT_NAME=${GITHUB_EVENT_NAME:-}
          CHANGELOG_FILE=/tmp/changelog.md
          echo "" > ${CHANGELOG_FILE}

          # Determine target commit (prefer origin/main)
          git fetch origin --tags main || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          # Use package.json at target commit for the version header when available
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            echo "v${TAG_VERSION}" >> ${CHANGELOG_FILE}
            echo "" >> ${CHANGELOG_FILE}
          fi

          # If this was a pull_request event, include the PR title (no body)
          if [ "${EVENT_NAME}" = "pull_request" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
            PR_NUM=$(jq -r '.pull_request.number' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
            PR_TITLE=$(jq -r '.pull_request.title' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
            if [ -n "${PR_NUM}" ] && [ "${PR_NUM}" != "null" ]; then
              echo "Merge PR #${PR_NUM}: ${PR_TITLE}" >> ${CHANGELOG_FILE}
              echo "" >> ${CHANGELOG_FILE}
            fi
          fi

          # Determine last tag reachable from the target commit and list commits since that tag
          # Prefer tags reachable from the target commit (so we don't accidentally pick a tag on a different branch)
          LAST_TAG=$(git describe --tags --abbrev=0 "${TARGET_COMMIT}" 2>/dev/null || true)
          if [ -z "${LAST_TAG}" ]; then
            echo "Changes:" >> ${CHANGELOG_FILE}
            RANGE="${TARGET_COMMIT}"
          else
            # If the last tag points to the same commit as the target (i.e., the tag was created on the
            # target commit), we want the commits that led up to that tag — use the previous merged tag
            # as the starting point when available.
            LAST_TAG_COMMIT=$(git rev-parse "${LAST_TAG}^{commit}" 2>/dev/null || true)
            TARGET_COMMIT_SHA=$(git rev-parse "${TARGET_COMMIT}" 2>/dev/null || true)
            if [ -n "${LAST_TAG_COMMIT}" ] && [ "${LAST_TAG_COMMIT}" = "${TARGET_COMMIT_SHA}" ]; then
              # find the previous tag merged into the target commit (sorted by creation date)
              PREV_TAG=$(git tag --sort=-creatordate --merged "${TARGET_COMMIT}" | sed -n '2p' || true)
              if [ -n "${PREV_TAG}" ]; then
                echo "Changes since ${PREV_TAG}:" >> ${CHANGELOG_FILE}
                RANGE="${PREV_TAG}..${TARGET_COMMIT}"
              else
                echo "Changes:" >> ${CHANGELOG_FILE}
                RANGE="${TARGET_COMMIT}"
              fi
            else
              echo "Changes since ${LAST_TAG}:" >> ${CHANGELOG_FILE}
              RANGE="${LAST_TAG}..${TARGET_COMMIT}"
            fi
          fi

          # Collect PR titles merged into main between the start and end of the range using
          # the GitHub Search API (merged date range). This reduces per-commit API calls.
          PRS_RAW=/tmp/prs_raw.txt
          PRS_UNIQ=/tmp/prs_uniq.txt
          > ${PRS_RAW}

          # Determine date range for merged PR search
          if echo "${RANGE}" | grep -q '\.\.'; then
            START_REF=$(echo "${RANGE}" | cut -d'.' -f1)
          else
            START_REF=""
          fi

          if [ -n "${START_REF}" ]; then
            START_DATE=$(git show -s --format=%cI ${START_REF} 2>/dev/null || true)
          else
            # fallback to a very early date when no start ref is available
            START_DATE="1970-01-01T00:00:00Z"
          fi
          END_DATE=$(git show -s --format=%cI ${TARGET_COMMIT} 2>/dev/null || true)

          if [ -n "${GITHUB_TOKEN:-}" ] && [ -n "${END_DATE}" ]; then
            # Build search query and URL-encode it using jq
            Q="repo:${GITHUB_REPOSITORY} type:pr is:merged base:main merged:${START_DATE}..${END_DATE}"
            ENCODED_Q=$(jq -nr --arg q "$Q" '$q|@uri')

            per_page=100
            page=1
            while :; do
              RESP=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/search/issues?q=${ENCODED_Q}&per_page=${per_page}&page=${page}" || true)
              # extract PR number and title
              echo "$RESP" | jq -r '.items[]? | "\(.number)\t\(.title)"' 2>/dev/null >> ${PRS_RAW} || true

              COUNT=$(echo "$RESP" | jq -r '.items | length' 2>/dev/null || echo 0)
              if [ "$COUNT" -lt "$per_page" ] || [ "$COUNT" -eq 0 ]; then
                break
              fi
              page=$((page+1))
            done
          fi

          # dedupe by PR number, keep first occurrence (which is newest by search ordering)
          if [ -s ${PRS_RAW} ]; then
            awk -F"\t" '!seen[$1]++ { print $0 }' ${PRS_RAW} > ${PRS_UNIQ} || true
          fi

          if [ -s ${PRS_UNIQ} ]; then
            echo "Pull requests included:" >> ${CHANGELOG_FILE}
            while IFS=$'\t' read -r num title; do
              echo "- PR #${num}: ${title}" >> ${CHANGELOG_FILE}
            done < ${PRS_UNIQ}
            echo "" >> ${CHANGELOG_FILE}
          fi

          # List commit subjects only (no bodies), include short hash and author
          git --no-pager log ${RANGE} --pretty=format:"- %s (%an, %h)" >> ${CHANGELOG_FILE} || true

          # If no commits were listed, add a helpful note
          if [ ! -s ${CHANGELOG_FILE} ] || [ "$(wc -c < ${CHANGELOG_FILE})" -le 0 ]; then
            echo "    (no commits found)" >> ${CHANGELOG_FILE}
          fi

          echo "Changelog generated at ${CHANGELOG_FILE}"
          cat ${CHANGELOG_FILE}

      - name: Create GitHub release (optional)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          CHANGELOG_FILE=/tmp/changelog.md
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases"

          # Determine the target commit and derive the tag from package.json at that commit
          git fetch origin --tags || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping release creation"
            # Post a comment to the PR (if available) so maintainers see why release was skipped
            if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
              if [ -n "${PR_NUM}" ]; then
                MSG="Release skipped: package.json not found at target commit ${TARGET_COMMIT}. Please ensure the bumped package.json was merged to main."
                curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
              fi
            fi
            exit 0
          fi

          # Ensure the tag exists on remote before creating a Release
          if ! git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} not found on remote; attempting to create tag ref via API"
            # attempt to create the tag ref pointing to TARGET_COMMIT via API (fallback when git push tags fails)
            API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/git/refs"
            REF_PAYLOAD=$(jq -nc --arg ref "refs/tags/${TAG_FROM_PKG}" --arg sha "${TARGET_COMMIT}" '{ref:$ref, sha:$sha}')
            CREATE_RESP=$(curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$REF_PAYLOAD" "$API_URL" || true)
            if echo "$CREATE_RESP" | jq -e .ref >/dev/null 2>&1; then
              echo "Created tag ref ${TAG_FROM_PKG} -> ${TARGET_COMMIT} via API"
            else
              echo "Failed to create tag ref via API; response: $CREATE_RESP" >&2
              # Post a comment to the PR so maintainers know a tag wasn't found
              if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
                PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
                if [ -n "${PR_NUM}" ]; then
                  MSG="Release skipped: tag ${TAG_FROM_PKG} not found on remote and API creation failed. The tag-step may have been skipped or branch protections prevented pushing the bump. Please merge the bump commit or create the tag manually."
                  curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
                fi
              fi
              exit 0
            fi
          fi

          # Use the tag as the Release name/title. Put the PR title (if available)
          # as the first line of the release body so the release page shows the
          # version as the title and the PR title as the lead line in the body.
          RELEASE_NAME="${TAG_FROM_PKG}"

          # Try to determine a PR title to include in the release body. Prefer the
          # event payload (works for pull_request-triggered runs), otherwise look up
          # PRs associated with the target commit.
          PR_TITLE=""
          PR_NUM=""
          if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
            PR_TITLE=$(jq -r '.pull_request.title // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
            PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
          fi

          if [ -z "${PR_TITLE}" ]; then
            PRS=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github.groot-preview+json" "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${TARGET_COMMIT}/pulls" || true)
            PR_TITLE=$(echo "$PRS" | jq -r '.[0].title // empty' 2>/dev/null || true)
            PR_NUM=$(echo "$PRS" | jq -r '.[0].number // empty' 2>/dev/null || true)
          fi

          # Build a leading PR line if we have a title/number
          PR_LEAD_LINE=""
          if [ -n "${PR_TITLE}" ]; then
            if [ -n "${PR_NUM}" ]; then
              PR_LEAD_LINE="Merge PR #${PR_NUM}: ${PR_TITLE}"
            else
              PR_LEAD_LINE="${PR_TITLE}"
            fi
          fi

          # Compose release body: PR lead line (if any) followed by the generated changelog
          if [ -n "${PR_LEAD_LINE}" ]; then
            BODY_CONTENT="${PR_LEAD_LINE}\n\n$(cat ${CHANGELOG_FILE} 2>/dev/null || true)"
          else
            BODY_CONTENT="$(cat ${CHANGELOG_FILE} 2>/dev/null || true)"
          fi

          BODY=$(jq -nc --arg tag "$TAG_FROM_PKG" --arg name "$RELEASE_NAME" --arg body "$BODY_CONTENT" '{tag_name:$tag, name:$name, body:$body, draft:false, prerelease:false}')
          echo "Creating release for ${TAG_FROM_PKG}"
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$BODY" "$API_URL" >/dev/null

  bump_dry_run:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dry-run bump (manual)
        id: dryrun
        env:
          PR_LABELS: ""
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          ./.github/scripts/bump-version.sh package.json auto --dry-run
