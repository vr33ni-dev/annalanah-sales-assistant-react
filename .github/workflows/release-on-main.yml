name: Release (create git tag) on merge to main

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  pull_request:
    types: [closed]
  workflow_dispatch:

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      run_release: ${{ steps.check.outputs.run_release }}
    steps:
      - name: Check whether this run should perform the release
        id: check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const eventName = process.env.GITHUB_EVENT_NAME || ''
            const eventPath = process.env.GITHUB_EVENT_PATH || ''

            // Trigger release when a PR targeting main was merged.
            if (eventName === 'pull_request' && eventPath) {
              const payload = require(eventPath)
              const pr = payload.pull_request || {}
              const merged = !!pr.merged
              const baseRef = pr.base && pr.base.ref ? pr.base.ref : ''
              if (merged && baseRef === 'main') {
                core.info('Pull request merged to main — proceeding with release run.')
                core.setOutput('run_release','true')
                return
              }
              core.info('Pull request closed but not a merged to main event — skipping release run.')
              core.setOutput('run_release','false')
              return
            }

            // Allow manual workflow dispatch
            if (eventName === 'workflow_dispatch') {
              core.info('Manual dispatch — proceeding with release run.')
              core.setOutput('run_release','true')
              return
            }

            core.info('Event not eligible for release run — skipping')
            core.setOutput('run_release','false')

  create_tag:
    needs: precheck
    concurrency:
      group: release-on-main-${{ github.ref }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Stop early if precheck decided not to run
        run: |
          if [ "${{ needs.precheck.outputs.run_release }}" != "true" ]; then
            echo "Precheck decided not to run release; stopping job."
            exit 0
          fi

      # remaining steps follow
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: |
          git fetch --tags origin

      - id: require_labels
        name: Require release label on merged PRs
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          PR_LABELS_JSON="[]"

          # Try to find PRs associated with the commit (this is live data so re-runs see updated labels).
          PR_INFO=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" \
            "https://api.github.com/repos/${GITHUB_REPOSITORY}/commits/${GITHUB_SHA}/pulls" \
            -H "Accept: application/vnd.github.groot-preview+json" || true)

          PR_LABELS_JSON=$(echo "$PR_INFO" | jq -c '.[0].labels // empty' 2>/dev/null || true)

          # If we couldn't locate a PR from the commit (e.g., unusual event), fall back to event payload labels for pull_request events
          if [ -z "${PR_LABELS_JSON}" ] || [ "${PR_LABELS_JSON}" = "null" ]; then
            if [ "${GITHUB_EVENT_NAME}" = "pull_request" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_LABELS_JSON=$(jq -c '.pull_request.labels // []' "${GITHUB_EVENT_PATH}" 2>/dev/null || echo "[]")
            else
              PR_LABELS_JSON="[]"
            fi
          fi

          # expose PR_LABELS as a step output for downstream steps
          echo "PR_LABELS=${PR_LABELS_JSON}" >> "${GITHUB_OUTPUT}"

          LABEL_NAMES=$(echo "$PR_LABELS_JSON" | jq -r '.[].name' || true)
          if [ -z "$(echo "$LABEL_NAMES" | tr -d '[:space:]')" ]; then
            echo "ERROR: Merged PR does not have a release label (major/minor/patch)."
            exit 1
          fi
          echo "Found labels: $LABEL_NAMES"

      - name: Auto bump version (label-driven)
        id: autobump
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          PR_LABELS: ${{ steps.require_labels.outputs.PR_LABELS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_SHA: ${{ github.sha }}
          BASE_REF: main
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          # run in apply mode so the script will modify package.json/VERSION as needed
          ./.github/scripts/bump-version.sh package.json auto --apply

      - name: Commit and push package.json (if changed)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          if git status --porcelain | grep -q '^'; then
            git add package.json package-lock.json || true
            # set git identity before committing to avoid author/identity errors on runners
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            git commit -m "chore(release): bump package.json version to $(jq -r .version package.json) [skip ci]" || true

            # Try to push directly to main
            if git push "https://x-access-token:${GITHUB_TOKEN}@github.com/${GITHUB_REPOSITORY}" HEAD:main; then
              echo "Pushed package.json to origin/main with GITHUB_TOKEN"
            else
              echo "Push to origin/main failed with GITHUB_TOKEN. Attempting to update package.json via the GitHub Contents API (may work with branch protection)."

              # prepare base64 content of package.json (single-line)
              if command -v base64 >/dev/null 2>&1; then
                NEW_CONTENT_B64=$(base64 package.json | tr -d '\n')
              else
                NEW_CONTENT_B64=$(cat package.json | base64 | tr -d '\n')
              fi

              REMOTE_PATH="package.json"
              MSG="chore(release): bump package.json to $(jq -r .version package.json) [skip ci]"

              # get current remote file to obtain sha
              REMOTE_JSON=$(curl -s -H "Authorization: token ${GITHUB_TOKEN}" "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${REMOTE_PATH}?ref=main" || true)
              REMOTE_SHA=$(echo "$REMOTE_JSON" | jq -r .sha 2>/dev/null || true)

              if [ -n "$REMOTE_SHA" ] && [ "$REMOTE_SHA" != "null" ]; then
                echo "Updating package.json on main via Contents API (sha=$REMOTE_SHA)"
                DATA=$(jq -n --arg message "$MSG" --arg content "$NEW_CONTENT_B64" --arg branch "main" --arg sha "$REMOTE_SHA" '{message:$message, content:$content, branch:$branch, sha:$sha}')
              else
                echo "Remote package.json not found or no sha; attempting to create via Contents API"
                DATA=$(jq -n --arg message "$MSG" --arg content "$NEW_CONTENT_B64" --arg branch "main" '{message:$message, content:$content, branch:$branch}')
              fi

              UPDATE_RESP=$(curl -s -X PUT -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$DATA" "https://api.github.com/repos/${GITHUB_REPOSITORY}/contents/${REMOTE_PATH}" || true)
              if echo "$UPDATE_RESP" | jq -e .content >/dev/null 2>&1; then
                echo "Successfully updated package.json on main via Contents API"
              else
                echo "Contents API update failed; cannot auto-apply bump due to branch protection. Response: $UPDATE_RESP" >&2
                # Instead of creating a fallback branch/PR (which may be blocked by org policy),
                # post an explanatory comment on the merged PR so maintainers can take action.
                if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
                  PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
                  if [ -n "$PR_NUM" ]; then
                    MSG="Automated release bump could not be applied to \`main\` due to branch protection. I attempted to update package.json to $(jq -r .version package.json) but the update was rejected. Please merge the bump into main (or allow Actions to create PRs) so the release can proceed."
                    echo "Posting note to PR #${PR_NUM}: $MSG"
                    curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
                  else
                    echo "No PR number found in event payload; cannot post explanatory comment."
                  fi
                else
                  echo "No event payload available; cannot post PR comment explaining blocked update."
                fi
                # Stop the release job so maintainers can resolve the bump manually (avoid creating unknown branches)
                echo "Release cannot continue until package.json is updated on main. Failing the job to surface the issue."
                exit 1
              fi
            fi
          else
            echo "No changes to commit"
          fi

      - name: Create v-tag and push (if package.json version)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail
          # fetch tags and remote main
          git fetch origin --tags

          # compute target commit: prefer origin/main (the pushed commit), otherwise local HEAD
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            echo "Local HEAD ($LOCAL_HEAD) differs from origin/main ($REMOTE_MAIN); tagging origin/main instead."
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          # derive tag from package.json at the target commit to ensure it matches the bumped version
          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping tag creation"
            exit 0
          fi

          # check remote for existing tag
          if git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} already exists on remote; skipping tag creation."
            exit 0
          fi

          # create annotated tag at the target commit and push
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git config user.name "github-actions[bot]"
          git tag -a "${TAG_FROM_PKG}" "$TARGET_COMMIT" -m "Release ${TAG_FROM_PKG}"
          git push origin "refs/tags/${TAG_FROM_PKG}"
          echo "Pushed tag ${TAG_FROM_PKG} -> ${TARGET_COMMIT}"

      - name: Generate changelog
        env:
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          EVENT_NAME=${GITHUB_EVENT_NAME}
          CHANGELOG_FILE=/tmp/changelog.md
          echo "" > ${CHANGELOG_FILE}
          # For PR merges include the PR title/body (cleaned) and then
          # append a list of commit messages (indented) since the last tag.
          PR_BODY_CLEAN=""
          if [ "$EVENT_NAME" = "pull_request" ]; then
            PR_NUM=$(jq -r '.pull_request.number' "$GITHUB_EVENT_PATH")
            PR_TITLE=$(jq -r '.pull_request.title' "$GITHUB_EVENT_PATH")
            PR_BODY_RAW=$(jq -r '.pull_request.body // ""' "$GITHUB_EVENT_PATH")

            # Remove HTML comment blocks (PR templates often use <!-- -->)
            PR_BODY_NOHTML=$(printf '%s\n' "$PR_BODY_RAW" | sed -E ':a;N;$!ba;s/<!--(.|\n)*?-->//g')

            # Extract the human-written description before template headings like '##' or 'IMPORTANT:'
            PR_BODY_CLEAN=$(printf '%s\n' "$PR_BODY_NOHTML" | awk '/^## /{exit} /^IMPORTANT:/{exit} {print}')
            # Trim leading/trailing whitespace/newlines
            PR_BODY_CLEAN=$(printf '%s' "$PR_BODY_CLEAN" | sed -E 's/^[[:space:]\n]+//; s/[[:space:]\n]+$//')

            echo "Merge PR #${PR_NUM}: ${PR_TITLE}" >> ${CHANGELOG_FILE}
            if [ -n "${PR_BODY_CLEAN}" ]; then
              echo "" >> ${CHANGELOG_FILE}
              echo "${PR_BODY_CLEAN}" >> ${CHANGELOG_FILE}
            fi
            echo "" >> ${CHANGELOG_FILE}
          fi

          # Determine target commit and last tag, then list commits since that tag.
          git fetch origin --tags origin main || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          LAST_TAG=$(git describe --tags --abbrev=0 origin/main 2>/dev/null || true)
          if [ -z "${LAST_TAG}" ]; then
            echo "Changes:" >> ${CHANGELOG_FILE}
            RANGE=""
          else
            echo "Changes since ${LAST_TAG}:" >> ${CHANGELOG_FILE}
            RANGE="${LAST_TAG}..${TARGET_COMMIT}"
          fi

          # List commit subjects and authors, indented to match previous style
          git --no-pager log ${RANGE} --pretty=format:"    %s (%an)" >> ${CHANGELOG_FILE} || true

          echo "Changelog generated at ${CHANGELOG_FILE}"
          cat ${CHANGELOG_FILE}

      - name: Create GitHub release (optional)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
        run: |
          set -euo pipefail
          CHANGELOG_FILE=/tmp/changelog.md
          API_URL="https://api.github.com/repos/${GITHUB_REPOSITORY}/releases"

          # Determine the target commit and derive the tag from package.json at that commit
          git fetch origin --tags || true
          LOCAL_HEAD=$(git rev-parse --verify HEAD)
          REMOTE_MAIN=$(git rev-parse --verify origin/main)
          if [ "$LOCAL_HEAD" != "$REMOTE_MAIN" ]; then
            TARGET_COMMIT="$REMOTE_MAIN"
          else
            TARGET_COMMIT="$LOCAL_HEAD"
          fi

          TAG_VERSION=$(git show ${TARGET_COMMIT}:package.json 2>/dev/null | jq -r .version 2>/dev/null || true)
          if [ -n "${TAG_VERSION}" ] && [ "${TAG_VERSION}" != "null" ]; then
            TAG_FROM_PKG="v${TAG_VERSION}"
          else
            echo "package.json not found at target commit ${TARGET_COMMIT}; skipping release creation"
            # Post a comment to the PR (if available) so maintainers see why release was skipped
            if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
              if [ -n "${PR_NUM}" ]; then
                MSG="Release skipped: package.json not found at target commit ${TARGET_COMMIT}. Please ensure the bumped package.json was merged to main."
                curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
              fi
            fi
            exit 0
          fi

          # Ensure the tag exists on remote before creating a Release
          if ! git ls-remote --exit-code --tags origin "refs/tags/${TAG_FROM_PKG}" >/dev/null 2>&1; then
            echo "Tag ${TAG_FROM_PKG} not found on remote; skipping release creation"
            # Post a comment to the PR so maintainers know a tag wasn't found
            if [ -n "${GITHUB_EVENT_PATH:-}" ] && [ -f "${GITHUB_EVENT_PATH}" ]; then
              PR_NUM=$(jq -r '.pull_request.number // empty' "${GITHUB_EVENT_PATH}" 2>/dev/null || true)
              if [ -n "${PR_NUM}" ]; then
                MSG="Release skipped: tag ${TAG_FROM_PKG} not found on remote. The tag-step may have been skipped or branch protections prevented pushing the bump. Please merge the bump commit or create the tag manually."
                curl -s -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$(jq -nc --arg body "$MSG" '{body:$body}')" "https://api.github.com/repos/${GITHUB_REPOSITORY}/issues/${PR_NUM}/comments" >/dev/null || true
              fi
            fi
            exit 0
          fi

          BODY=$(jq -nc --arg tag "$TAG_FROM_PKG" --arg body "$(cat ${CHANGELOG_FILE} 2>/dev/null || true)" '{tag_name:$tag, name:$tag, body:$body, draft:false, prerelease:false}')
          echo "Creating release for ${TAG_FROM_PKG}"
          curl -s -H "Authorization: token ${GITHUB_TOKEN}" -H "Content-Type: application/json" -d "$BODY" "$API_URL" >/dev/null

  bump_dry_run:
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Dry-run bump (manual)
        id: dryrun
        env:
          PR_LABELS: ""
        run: |
          set -euo pipefail
          chmod +x .github/scripts/bump-version.sh || true
          ./.github/scripts/bump-version.sh package.json auto --dry-run
