name: Release (create git tag) on merge to main

permissions:
  contents: write
  issues: write
  pull-requests: write

on:
  pull_request:
    types: [closed]
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  precheck:
    runs-on: ubuntu-latest
    outputs:
      run_release: ${{ steps.check.outputs.run_release }}
    steps:
      - name: Check whether this run should perform the release
        id: check
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const eventName = process.env.GITHUB_EVENT_NAME || ''
            const eventPath = process.env.GITHUB_EVENT_PATH || ''

            // Trigger release when a PR targeting main was merged.
            if (eventName === 'pull_request' && eventPath) {
              const payload = require(eventPath)
              const pr = payload.pull_request || {}
              const merged = !!pr.merged
              const baseRef = pr.base && pr.base.ref ? pr.base.ref : ''
                if (merged && baseRef === 'main') {
                  core.info('Pull request merged to main — checking whether a release/tag already exists for the merged commit')
                  // If the PR contains a merge_commit_sha, try to read package.json at
                  // that exact commit and skip the run if a matching tag/release already
                  // exists. This avoids the PR-triggered run doing bump/tag work when a
                  // nearly-simultaneous push-run already created the release.
                  try {
                    const mergeSha = pr.merge_commit_sha || null
                    if (mergeSha) {
                      let version = null
                      try {
                        const pkg = await github.rest.repos.getContent({ owner: payload.repository.owner.login, repo: payload.repository.name, path: 'package.json', ref: mergeSha })
                        const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                        const parsed = JSON.parse(content || '{}')
                        version = parsed.version || null
                      } catch (e) {
                        core.info('Could not read package.json at merge commit; will proceed with release run as fallback')
                      }

                      if (version) {
                        const tag = `v${version}`
                        try {
                          await github.rest.repos.getReleaseByTag({ owner: payload.repository.owner.login, repo: payload.repository.name, tag })
                          core.info(`Release for ${tag} already exists — skipping release run for merged PR.`)
                          core.setOutput('run_release','false')
                          return
                        } catch (e) {
                          // Not found — continue to check refs
                        }

                        try {
                          await github.rest.git.getRef({ owner: payload.repository.owner.login, repo: payload.repository.name, ref: `refs/tags/${tag}` })
                          core.info(`Tag ${tag} already exists — skipping release run for merged PR.`)
                          core.setOutput('run_release','false')
                          return
                        } catch (e) {
                          // Tag not found — proceed
                        }
                      }
                    }
                  } catch (err) {
                    core.info('Error while checking tags/releases for merged PR; proceeding with release run as a safe fallback.')
                  }
                  core.info('Pull request merged to main — proceeding with release run.')
                  core.setOutput('run_release','true')
                  return
                }
                core.info('Pull request closed but not a merged to main event — skipping release run.')
                core.setOutput('run_release','false')
                return
            }

            // For pushes, run only for pushes to main and only when a release/tag for the
            // package.json version is not already present on the repo. This covers the
            // GitHub behavior where merges that change workflow files may not trigger
            // the pull_request workflow run: the push event will act as a fallback.
            if (eventName === 'push') {
              const ref = process.env.GITHUB_REF || ''
              if (ref !== 'refs/heads/main') {
                core.info('Push event is not to main — skipping')
                core.setOutput('run_release','false')
                return
              }

              core.info('Push to main detected — checking for existing release/tag to avoid duplicate runs')
              try {
                const [owner, repo] = (process.env.GITHUB_REPOSITORY || '').split('/')
                const sha = process.env.GITHUB_SHA || ''

                // Try to read package.json at the pushed commit to derive the version
                let version = null
                try {
                  const pkg = await github.rest.repos.getContent({ owner, repo, path: 'package.json', ref: sha })
                  const content = Buffer.from(pkg.data.content, pkg.data.encoding).toString()
                  const parsed = JSON.parse(content || '{}')
                  version = parsed.version || null
                } catch (e) {
                  core.info('Could not read package.json at pushed commit; will proceed with release run as a fallback')
                }

                if (version) {
                  const tag = `v${version}`
                  // If a Release already exists for this tag, skip
                  try {
                    await github.rest.repos.getReleaseByTag({ owner, repo, tag })
                    core.info(`Release for ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Not found — continue to check refs
                  }

                  try {
                    await github.rest.git.getRef({ owner, repo, ref: `refs/tags/${tag}` })
                    core.info(`Tag ${tag} already exists — skipping release run.`)
                    core.setOutput('run_release','false')
                    return
                  } catch (e) {
                    // Tag not found — proceed
                  }
                }

                core.info('No existing release/tag detected for pushed commit — proceeding with release run.')
                // Before deciding to run, check whether this push corresponds to a
                // PR merge and whether a pull_request-triggered release run already
                // executed for that merge. If so, skip the push-run to avoid a
                // duplicate release execution.
                try {
                  // Query PRs associated with the pushed commit (may be empty)
                  const prsResp = await github.request('GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls', { owner, repo, commit_sha: sha })
                  const prs = prsResp.data || []
                  const mergedPr = prs.find(p => p.base && p.base.ref === 'main' && p.merged_at)
                  if (mergedPr && mergedPr.number) {
                    core.info(`Push commit ${sha} is associated with merged PR #${mergedPr.number}; checking for a pull_request-triggered release run.`)
                    // Poll briefly for a pull_request-triggered run of this workflow for the same head SHA.
                    // Race conditions can occur where the push event fires before the PR-triggered run
                    // is created; wait a short time (up to ~30s) for that run to appear before
                    // deciding to proceed with the push-run fallback.
                    let skipped = false
                    const maxAttempts = 6
                    for (let attempt = 0; attempt < maxAttempts; attempt++) {
                      try {
                        const wfResp = await github.request('GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs', { owner, repo, workflow_id: 'release-on-main.yml', head_sha: sha, event: 'pull_request', per_page: 1 })
                        const runs = (wfResp.data && wfResp.data.workflow_runs) || []
                        if (runs.length > 0) {
                          const run = runs[0]
                          core.info(`Found pull_request-triggered release workflow run for head ${sha} (id=${run.id}, status=${run.status}, conclusion=${run.conclusion})`)
                          // Only skip the push-run if the PR-run completed successfully.
                          if (run.conclusion === 'success') {
                            core.info(`PR-run concluded successfully (id=${run.id}) — skipping push-run.`)
                            core.setOutput('run_release','false')
                            skipped = true
                            break
                          }
                          // If the PR-run is still in progress or queued, wait and retry
                          if (run.status === 'in_progress' || run.status === 'queued') {
                            core.info('PR-run still in progress; waiting briefly for completion before deciding.')
                          } else {
                            // PR-run finished but did not succeed — do not skip
                            core.info('PR-run finished but did not succeed; will not skip push-run.')
                            break
                          }
                        }
                      } catch (e) {
                        core.info('Error checking for pull_request runs; will retry briefly.')
                      }
                      // wait 5s before next attempt
                      await new Promise(resolve => setTimeout(resolve, 5000))
                    }
                    if (skipped) return
                  }
                } catch (e) {
                  core.info('Error while checking for an existing pull_request run for this push; proceeding with release run as fallback.')
                }

                core.setOutput('run_release','true')
                return
              } catch (err) {
                core.info('Error while checking tags/releases for push; proceeding to run release as a safe fallback.')
                core.setOutput('run_release','true')
                return
              }
            }

            // Allow manual workflow dispatch
            if (eventName === 'workflow_dispatch') {
              core.info('Manual dispatch — proceeding with release run.')
              core.setOutput('run_release','true')
              return
            }

            core.info('Event not eligible for release run — skipping')
            core.setOutput('run_release','false')

  create_tag:
    needs: precheck
    concurrency:
      group: release-on-main-${{ github.ref }}
      cancel-in-progress: false
    runs-on: ubuntu-latest
    steps:
      - name: Stop early if precheck decided not to run
        run: |
          if [ "${{ needs.precheck.outputs.run_release }}" != "true" ]; then
            echo "Precheck decided not to run release; stopping job."
            exit 0
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run consolidated release script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_EVENT_NAME: ${{ github.event_name }}
          GITHUB_SHA: ${{ github.sha }}
        run: |
          set -euo pipefail
          chmod +x .github/scripts/release-on-main.sh || true
          ./.github/scripts/release-on-main.sh

          # Release creation handled by the consolidated script.
          # The consolidated script generates the changelog and creates the GitHub release.
